import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, boolean, integer, decimal, jsonb, pgEnum, uniqueIndex, check } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// ===================== DRIZZLE ENUMS FOR TYPE SAFETY =====================

// User and System Enums
export const userRoleEnum = pgEnum('user_role', ['user', 'admin', 'dha_officer', 'manager', 'super_admin']);
export const severityEnum = pgEnum('severity', ['low', 'medium', 'high', 'critical']);
export const genderEnum = pgEnum('gender', ['M', 'F', 'X']); // Including non-binary option
export const statusEnum = pgEnum('status', ['active', 'inactive', 'suspended', 'revoked', 'expired', 'pending']);

// Document and Processing Enums - Complete 21 DHA Document Types
export const documentTypeEnum = pgEnum('document_type', [
  // Identity Documents (3)
  'smart_id_card',
  'identity_document_book',
  'temporary_id_certificate',
  
  // Travel Documents (3)
  'south_african_passport',
  'emergency_travel_certificate',
  'refugee_travel_document',
  
  // Civil Documents (4)
  'birth_certificate',
  'death_certificate', 
  'marriage_certificate',
  'divorce_certificate',
  
  // Immigration Documents (11)
  'general_work_visa',
  'critical_skills_work_visa',
  'intra_company_transfer_work_visa',
  'business_visa',
  'study_visa_permit',
  'visitor_visa',
  'medical_treatment_visa',
  'retired_person_visa',
  'exchange_visa',
  'relatives_visa',
  'permanent_residence_permit',
  
  // Additional DHA Documents (2)
  'certificate_of_exemption',
  'certificate_of_south_african_citizenship',
  
  // Legacy compatibility (keep existing data working)
  'passport', 'sa_id', 'smart_id', 'temporary_id',
  'study_permit', 'work_permit', 'business_permit', 'transit_visa',
  'permanent_residence', 'temporary_residence', 'refugee_permit', 'asylum_permit',
  'diplomatic_passport', 'exchange_permit'
]);

export const processingStatusEnum = pgEnum('processing_status', [
  'pending', 'processing', 'validated', 'verified', 'approved', 'rejected', 'issued', 'delivered'
]);

// DHA 8-Stage Workflow Enums
export const workflowStageEnum = pgEnum('workflow_stage', [
  'draft', 'identity_verification', 'eligibility_check', 'background_verification', 
  'payment', 'adjudication', 'approved', 'issued'
]);

export const workflowStatusEnum = pgEnum('workflow_status', [
  'in_progress', 'completed', 'rejected', 'on_hold', 'cancelled'
]);

// Security and Classification Enums
export const classificationLevelEnum = pgEnum('classification_level', [
  'unclassified', 'official', 'confidential', 'secret', 'top_secret'
]);

export const riskLevelEnum = pgEnum('risk_level', ['low', 'medium', 'high', 'critical']);
export const priorityLevelEnum = pgEnum('priority_level', ['low', 'normal', 'high', 'urgent']);

// Verification and Check Enums
export const verificationTypeEnum = pgEnum('verification_type', [
  'npr', 'abis', 'saps_crc', 'icao_pkd', 'mrz', 'biometric', 'document_authenticity'
]);

export const verificationResultEnum = pgEnum('verification_result', [
  'verified', 'not_verified', 'inconclusive', 'failed', 'pending'
]);

// Payment and Delivery Enums
export const paymentStatusEnum = pgEnum('payment_status', [
  'pending', 'processing', 'paid', 'failed', 'refunded', 'cancelled'
]);

export const paymentMethodEnum = pgEnum('payment_method', [
  'card', 'eft', 'cash', 'bank_transfer', 'mobile_payment'
]);

export const deliveryMethodEnum = pgEnum('delivery_method', [
  'collection', 'courier', 'registered_mail', 'secure_courier'
]);

export const deliveryStatusEnum = pgEnum('delivery_status', [
  'pending', 'in_transit', 'delivered', 'failed', 'returned'
]);

// Print Status Enum (for document printing pipeline)
export const printStatusEnum = pgEnum('print_status', [
  'queued', 'printing', 'printed', 'quality_check', 'ready', 'failed'
]);

// Contact Method Enum
export const preferredContactMethodEnum = pgEnum('preferred_contact_method', [
  'sms', 'email', 'phone', 'mail', 'whatsapp'
]);

// Diplomatic Immunity Status Enum
export const immunityStatusEnum = pgEnum('immunity_status', [
  'full', 'partial', 'none', 'consular'
]);

// Document Verification Stage Enum
export const verificationStageEnum = pgEnum('verification_stage', [
  'initial', 'document_check', 'biometric_check', 'background_check', 'final_review', 'completed'
]);

// Biometric and Security Enums
export const biometricTypeEnum = pgEnum('biometric_type', [
  'fingerprint', 'faceprint', 'iris', 'voiceprint', 'signature'
]);

export const encryptionAlgorithmEnum = pgEnum('encryption_algorithm', [
  'AES-256-GCM', 'ChaCha20-Poly1305', 'RSA-OAEP', 'ECIES'
]);

export const signatureAlgorithmEnum = pgEnum('signature_algorithm', [
  'RSA-PSS', 'ECDSA', 'EdDSA', 'RSASSA-PKCS1-v1_5'
]);

// Nationality and Country Enums (key ones for DHA)
export const countryEnum = pgEnum('country', [
  'ZA', 'ZW', 'MZ', 'BW', 'LS', 'SZ', 'NA', 'MW', 'ZM', 'TZ', 'KE', 'UG', 'RW',
  'US', 'UK', 'DE', 'FR', 'CN', 'IN', 'BR', 'AU', 'CA', 'OTHER'
]);

export const provinceEnum = pgEnum('province', [
  'Eastern Cape', 'Free State', 'Gauteng', 'KwaZulu-Natal', 
  'Limpopo', 'Mpumalanga', 'Northern Cape', 'North West', 'Western Cape'
]);

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  role: userRoleEnum("role").notNull().default("user"),
  isActive: boolean("is_active").notNull().default(true),
  
  // Account lockout fields for brute force protection
  failedAttempts: integer("failed_attempts").notNull().default(0),
  lockedUntil: timestamp("locked_until"),
  lastFailedAttempt: timestamp("last_failed_attempt"),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const conversations = pgTable("conversations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  lastMessageAt: timestamp("last_message_at").notNull().default(sql`now()`),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const messages = pgTable("messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  conversationId: varchar("conversation_id").notNull().references(() => conversations.id),
  role: text("role").notNull(), // 'user' or 'assistant'
  content: text("content").notNull(),
  metadata: jsonb("metadata"), // For storing additional data like context used
  attachments: jsonb("attachments"), // For storing document attachments with OCR data
  aiContext: jsonb("ai_context"), // AI-specific context like extracted fields, suggestions
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// AI Assistant Document Processing Sessions
export const aiDocumentSessions = pgTable("ai_document_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  conversationId: varchar("conversation_id").references(() => conversations.id),
  documentId: varchar("document_id").references(() => documents.id),
  documentType: documentTypeEnum("document_type").notNull(),
  
  // OCR Processing Results
  ocrResults: jsonb("ocr_results"), // Full OCR extraction results
  extractedFields: jsonb("extracted_fields"), // Structured field data
  mrzData: jsonb("mrz_data"), // MRZ parsing results for passports
  
  // Auto-Fill Mapping
  fieldMappings: jsonb("field_mappings"), // Maps OCR fields to form fields
  autoFillData: jsonb("auto_fill_data"), // Data ready for form population
  
  // AI Analysis
  aiAnalysis: jsonb("ai_analysis"), // AI insights about the document
  suggestions: jsonb("suggestions"), // AI suggestions for form completion
  validationIssues: jsonb("validation_issues"), // Identified issues
  
  // Processing Status
  processingStatus: processingStatusEnum("processing_status").notNull().default("pending"),
  confidenceScore: integer("confidence_score"), // Overall processing confidence 0-100
  qualityScore: integer("quality_score"), // Document quality score 0-100
  
  // Metadata
  processingStarted: timestamp("processing_started").notNull().default(sql`now()`),
  processingCompleted: timestamp("processing_completed"),
  processingDuration: integer("processing_duration"), // milliseconds
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Document Auto-Fill Templates - Defines how to map OCR data to forms
export const documentAutoFillTemplates = pgTable("document_auto_fill_templates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description"),
  documentType: documentTypeEnum("document_type").notNull(),
  targetFormType: text("target_form_type").notNull(), // e.g., 'passport_application', 'work_permit_form'
  
  // Field Mapping Configuration
  fieldMappings: jsonb("field_mappings").notNull(), // OCR field -> Form field mappings
  requiredFields: jsonb("required_fields"), // Required fields for this template
  optionalFields: jsonb("optional_fields"), // Optional fields that can be auto-filled
  
  // Validation Rules
  validationRules: jsonb("validation_rules"), // Rules for validating extracted data
  dataTransformations: jsonb("data_transformations"), // Transform rules for data format conversion
  
  // AI Configuration
  aiPromptTemplate: text("ai_prompt_template"), // Template for AI assistance prompts
  aiValidationPrompt: text("ai_validation_prompt"), // AI validation instructions
  
  // Template Metadata
  version: text("version").notNull().default("1.0"),
  isActive: boolean("is_active").notNull().default(true),
  priority: integer("priority").notNull().default(0), // Higher priority templates used first
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// OCR Field Definitions - Standardized field definitions for OCR extraction
export const ocrFieldDefinitions = pgTable("ocr_field_definitions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  fieldName: text("field_name").notNull().unique(), // e.g., 'passport_number', 'full_name', 'date_of_birth'
  displayName: text("display_name").notNull(), // Human-readable field name
  description: text("description"),
  dataType: text("data_type").notNull(), // 'text', 'date', 'number', 'boolean', 'email', 'phone'
  
  // Field Properties
  category: text("category").notNull(), // 'personal', 'document', 'address', 'contact'
  isRequired: boolean("is_required").notNull().default(false),
  isVerificationField: boolean("is_verification_field").notNull().default(false),
  
  // Validation Configuration
  validationPattern: text("validation_pattern"), // Regex pattern for validation
  minLength: integer("min_length"),
  maxLength: integer("max_length"),
  allowedValues: jsonb("allowed_values"), // Array of allowed values for select fields
  
  // Processing Hints
  extractionHints: jsonb("extraction_hints"), // Hints for OCR extraction
  commonVariations: jsonb("common_variations"), // Common variations of field names
  relatedFields: jsonb("related_fields"), // Fields that should be processed together
  
  // Internationalization
  translations: jsonb("translations"), // Translations for all 11 SA languages
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// AI Assistant Knowledge Base - Document requirements and guidance
export const aiKnowledgeBase = pgTable("ai_knowledge_base", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  category: text("category").notNull(), // 'document_requirements', 'processing_times', 'fees', 'procedures'
  documentType: documentTypeEnum("document_type"),
  topic: text("topic").notNull(),
  title: text("title").notNull(),
  content: text("content").notNull(),
  
  // Multilingual Support
  language: text("language").notNull().default("en"),
  translations: jsonb("translations"), // Content in all 11 SA languages
  
  // Metadata
  keywords: jsonb("keywords"), // Search keywords
  tags: jsonb("tags"), // Categorization tags
  priority: integer("priority").notNull().default(0),
  
  // Versioning
  version: text("version").notNull().default("1.0"),
  isActive: boolean("is_active").notNull().default(true),
  effectiveDate: timestamp("effective_date").notNull().default(sql`now()`),
  expiryDate: timestamp("expiry_date"),
  
  // Usage Statistics
  viewCount: integer("view_count").notNull().default(0),
  useCount: integer("use_count").notNull().default(0),
  lastUsed: timestamp("last_used"),
  
  createdBy: varchar("created_by").references(() => users.id),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// AI Conversation Analytics - Track AI assistant performance and usage
export const aiConversationAnalytics = pgTable("ai_conversation_analytics", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  conversationId: varchar("conversation_id").notNull().references(() => conversations.id),
  userId: varchar("user_id").references(() => users.id),
  
  // Conversation Metrics
  totalMessages: integer("total_messages").notNull().default(0),
  averageResponseTime: integer("average_response_time"), // milliseconds
  userSatisfactionRating: integer("user_satisfaction_rating"), // 1-5 scale
  
  // Content Analysis
  topicsDiscussed: jsonb("topics_discussed"), // Array of topics
  documentsProcessed: jsonb("documents_processed"), // Documents handled in conversation
  formsAutoFilled: jsonb("forms_auto_filled"), // Forms that were auto-filled
  
  // Language and Localization
  primaryLanguage: text("primary_language").notNull().default("en"),
  languagesSwitched: jsonb("languages_switched"), // Languages used during conversation
  
  // Success Metrics
  taskCompleted: boolean("task_completed").notNull().default(false),
  assistanceEffectiveness: integer("assistance_effectiveness"), // 1-100 score
  errorCount: integer("error_count").notNull().default(0),
  
  // Technical Metrics
  ocrProcessingCount: integer("ocr_processing_count").notNull().default(0),
  autoFillSuccessRate: decimal("auto_fill_success_rate", { precision: 5, scale: 2 }), // Percentage
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

export const documents = pgTable("documents", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  filename: text("filename").notNull(),
  originalName: text("original_name").notNull(),
  mimeType: text("mime_type").notNull(),
  size: integer("size").notNull(),
  storagePath: text("storage_path").notNull(),
  encryptionKey: text("encryption_key"),
  isEncrypted: boolean("is_encrypted").notNull().default(false),
  processingStatus: processingStatusEnum("processing_status").notNull().default("pending"),
  ocrText: text("ocr_text"),
  ocrConfidence: integer("ocr_confidence"),
  isVerified: boolean("is_verified"),
  verificationScore: integer("verification_score"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const securityEvents = pgTable("security_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id),
  eventType: text("event_type").notNull(),
  severity: severityEnum("severity").notNull(),
  details: jsonb("details"),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  location: text("location"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const fraudAlerts = pgTable("fraud_alerts", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  alertType: text("alert_type").notNull(),
  riskScore: integer("risk_score").notNull(),
  details: jsonb("details"),
  isResolved: boolean("is_resolved").notNull().default(false),
  resolvedBy: varchar("resolved_by").references(() => users.id),
  resolvedAt: timestamp("resolved_at"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const systemMetrics = pgTable("system_metrics", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  metricType: text("metric_type").notNull(),
  value: integer("value").notNull(),
  unit: text("unit").notNull(),
  timestamp: timestamp("timestamp").notNull().default(sql`now()`),
});

export const quantumKeys = pgTable("quantum_keys", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  keyId: text("key_id").notNull().unique(),
  algorithm: text("algorithm").notNull(),
  keyData: text("key_data").notNull(),
  entropy: integer("entropy").notNull(),
  isActive: boolean("is_active").notNull().default(true),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const errorLogs = pgTable("error_logs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  timestamp: timestamp("timestamp").notNull().default(sql`now()`),
  errorType: text("error_type").notNull(), // database, api, validation, authentication, etc.
  message: text("message").notNull(),
  stack: text("stack"),
  userId: varchar("user_id").references(() => users.id),
  requestUrl: text("request_url"),
  requestMethod: text("request_method"),
  statusCode: integer("status_code"),
  severity: severityEnum("severity").notNull(),
  context: jsonb("context"), // Additional error context
  environment: text("environment").notNull().default("development"),
  isResolved: boolean("is_resolved").notNull().default(false),
  resolvedBy: varchar("resolved_by").references(() => users.id),
  resolvedAt: timestamp("resolved_at"),
  userAgent: text("user_agent"),
  ipAddress: text("ip_address"),
  sessionId: text("session_id"),
  errorCount: integer("error_count").notNull().default(1), // For tracking repeated errors
});

// Refugee and Asylum Documentation Tables
export const refugeeDocuments = pgTable("refugee_documents", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  documentType: documentTypeEnum("document_type").notNull(),
  unhcrNumber: text("unhcr_number"),
  countryOfOrigin: text("country_of_origin").notNull(),
  dateOfEntry: timestamp("date_of_entry").notNull(),
  campLocation: text("camp_location"),
  dependents: jsonb("dependents"), // Array of dependent information
  permitNumber: text("permit_number"),
  permitExpiryDate: timestamp("permit_expiry_date"),
  maroonPassportNumber: text("maroon_passport_number"),
  integrationStatus: statusEnum("integration_status"),
  biometricCaptured: boolean("biometric_captured").notNull().default(false),
  verificationStatus: verificationResultEnum("verification_status").notNull().default("pending"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at"),
});

// Diplomatic Passport Table
export const diplomaticPassports = pgTable("diplomatic_passports", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  passportNumber: text("passport_number").unique(),
  diplomaticNoteNumber: text("diplomatic_note_number").notNull(),
  embassy: text("embassy").notNull(),
  consulate: text("consulate"),
  diplomaticRank: text("diplomatic_rank").notNull(),
  immunityStatus: immunityStatusEnum("immunity_status").notNull(),
  viennaConventionCompliant: boolean("vienna_convention_compliant").notNull().default(true),
  specialClearance: jsonb("special_clearance"), // Security clearance details
  issueDate: timestamp("issue_date"),
  expiryDate: timestamp("expiry_date"),
  countryOfAccreditation: text("country_of_accreditation").notNull(),
  previousDiplomaticPassports: jsonb("previous_diplomatic_passports"),
  emergencyContactEmbassy: text("emergency_contact_embassy"),
  status: statusEnum("status").notNull().default("pending"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Document Delivery Tracking Table
export const documentDelivery = pgTable("document_delivery", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull().references(() => documents.id),
  documentType: documentTypeEnum("document_type").notNull(),
  userId: varchar("user_id").notNull().references(() => users.id),
  deliveryMethod: deliveryMethodEnum("delivery_method").notNull(),
  collectionPoint: text("collection_point"), // DHA office location
  courierTrackingNumber: text("courier_tracking_number"),
  // STRUCTURED DELIVERY ADDRESS (replacing jsonb catch-all)
  deliveryStreetAddress: text("delivery_street_address"),
  deliverySuburb: text("delivery_suburb"),
  deliveryCity: text("delivery_city"),
  deliveryProvince: text("delivery_province"),
  deliveryPostalCode: text("delivery_postal_code"),
  deliveryCountry: text("delivery_country").default("South Africa"),
  deliverySpecialInstructions: text("delivery_special_instructions"),
  printStatus: printStatusEnum("print_status").notNull().default("queued"),
  printQueuePosition: integer("print_queue_position"),
  printedAt: timestamp("printed_at"),
  qualityCheckPassed: boolean("quality_check_passed"),
  estimatedDeliveryDate: timestamp("estimated_delivery_date"),
  actualDeliveryDate: timestamp("actual_delivery_date"),
  deliveryStatus: deliveryStatusEnum("delivery_status").notNull().default("pending"),
  recipientName: text("recipient_name"),
  recipientIdNumber: text("recipient_id_number"),
  recipientSignature: text("recipient_signature"), // Base64 encoded signature
  // STRUCTURED NOTIFICATION PREFERENCES (replacing jsonb catch-all)
  notifySms: boolean("notify_sms").notNull().default(true),
  notifyEmail: boolean("notify_email").notNull().default(true),
  notifyPush: boolean("notify_push").notNull().default(false),
  notifyPhysicalMail: boolean("notify_physical_mail").notNull().default(false),
  preferredContactMethod: preferredContactMethodEnum("preferred_contact_method").default("sms"),
  deliveryAttempts: integer("delivery_attempts").notNull().default(0),
  deliveryNotes: text("delivery_notes"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at"),
});

// AMS Certificate Table (Asylum Management System)
export const amsCertificates = pgTable("ams_certificates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  certificateNumber: text("certificate_number").unique(),
  certificateType: text("certificate_type").notNull(), // 'refugee_status', 'asylum_seeker', 'temporary_protection', 'permanent_protection'
  applicantName: text("applicant_name").notNull(),
  nationality: text("nationality").notNull(),
  unhcrNumber: text("unhcr_number"),
  asylumClaimNumber: text("asylum_claim_number"),
  status: text("status").notNull().default("pending_verification"), // 'pending_verification', 'verified', 'expired', 'revoked', 'suspended'
  issueDate: timestamp("issue_date"),
  expiryDate: timestamp("expiry_date"),
  verificationDate: timestamp("verification_date"),
  verifiedBy: varchar("verified_by").references(() => users.id),
  rejectionReason: text("rejection_reason"),
  suspensionReason: text("suspension_reason"),
  revocationReason: text("revocation_reason"),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  // SECURITY FIX: Biometric data moved to encrypted storage
  // biometricData removed - use encryptedArtifacts table for sensitive data
  biometricArtifactId: varchar("biometric_artifact_id").references(() => encryptedArtifacts.id),
  
  // STRUCTURED ENDORSEMENTS AND RESTRICTIONS (replacing jsonb catch-alls)
  endorsements: text("endorsements").array(), // Array of endorsement codes
  restrictions: text("restrictions").array(), // Array of restriction codes
  renewalEligible: boolean("renewal_eligible").notNull().default(false),
  renewalDate: timestamp("renewal_date"),
  previousCertificateId: varchar("previous_certificate_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at"),
});

// Permit Status Change Table
export const permitStatusChanges = pgTable("permit_status_changes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  permitId: varchar("permit_id").notNull(),
  permitType: text("permit_type").notNull(), // 'work', 'study', 'visitor', 'permanent_residence', 'refugee'
  previousStatus: text("previous_status").notNull(),
  newStatus: text("new_status").notNull(), // 'applied', 'processing', 'approved', 'rejected', 'issued', 'active', 'expired', 'renewed'
  changedBy: varchar("changed_by").notNull().references(() => users.id),
  changeReason: text("change_reason").notNull(),
  changeNotes: text("change_notes"),
  endorsementsAdded: jsonb("endorsements_added"),
  endorsementsRemoved: jsonb("endorsements_removed"),
  conditionsModified: jsonb("conditions_modified"),
  gracePeriodDays: integer("grace_period_days"),
  renewalStatus: text("renewal_status"), // 'eligible', 'pending', 'approved', 'rejected'
  renewalDeadline: timestamp("renewal_deadline"),
  effectiveDate: timestamp("effective_date").notNull(),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Document Verification Status Table
export const documentVerificationStatus = pgTable("document_verification_status", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull(),
  documentType: documentTypeEnum("document_type").notNull(),
  currentStatus: processingStatusEnum("current_status").notNull(),
  previousStatus: text("previous_status"),
  statusChangeReason: text("status_change_reason"),
  verificationStage: verificationStageEnum("verification_stage").notNull(),
  verificationScore: integer("verification_score"),
  authenticityCheckPassed: boolean("authenticity_check_passed"),
  biometricCheckPassed: boolean("biometric_check_passed"),
  backgroundCheckPassed: boolean("background_check_passed"),
  rejectionReasons: jsonb("rejection_reasons"),
  resubmissionAllowed: boolean("resubmission_allowed").notNull().default(true),
  resubmissionCount: integer("resubmission_count").notNull().default(0),
  qrCodeVerified: boolean("qr_code_verified"),
  qrCodeVerificationDate: timestamp("qr_code_verification_date"),
  estimatedCompletionDate: timestamp("estimated_completion_date"),
  actualCompletionDate: timestamp("actual_completion_date"),
  notificationsSent: jsonb("notifications_sent"),
  updatedBy: varchar("updated_by").references(() => users.id),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at"),
});

// Live Document Verification History Table
export const liveDocumentVerificationHistory = pgTable("live_document_verification_history", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull(),
  documentType: text("document_type").notNull(),
  action: text("action").notNull(), // 'status_change', 'verification_complete', 'rejection', 'resubmission', 'approval'
  previousValue: text("previous_value"),
  newValue: text("new_value"),
  actionBy: varchar("action_by").references(() => users.id),
  actionReason: text("action_reason"),
  actionNotes: text("action_notes"),
  metadata: jsonb("metadata"),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});


// DHA Office Locations Table
export const dhaOffices = pgTable("dha_offices", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  officeName: text("office_name").notNull(),
  officeCode: text("office_code").notNull().unique(),
  province: text("province").notNull(),
  city: text("city").notNull(),
  address: text("address").notNull(),
  postalCode: text("postal_code"),
  phoneNumber: text("phone_number"),
  emailAddress: text("email_address"),
  // STRUCTURED OPERATING HOURS (replacing jsonb catch-all)
  mondayOpen: text("monday_open"), // "08:00" format
  mondayClose: text("monday_close"), // "17:00" format
  tuesdayOpen: text("tuesday_open"),
  tuesdayClose: text("tuesday_close"),
  wednesdayOpen: text("wednesday_open"),
  wednesdayClose: text("wednesday_close"),
  thursdayOpen: text("thursday_open"),
  thursdayClose: text("thursday_close"),
  fridayOpen: text("friday_open"),
  fridayClose: text("friday_close"),
  saturdayOpen: text("saturday_open"), // Optional for Saturday service
  saturdayClose: text("saturday_close"),
  sundayOpen: text("sunday_open"), // Optional for Sunday service
  sundayClose: text("sunday_close"),
  
  servicesOffered: text().array(), // Array of services
  hasRefugeeServices: boolean("has_refugee_services").notNull().default(false),
  hasDiplomaticServices: boolean("has_diplomatic_services").notNull().default(false),
  collectionAvailable: boolean("collection_available").notNull().default(true),
  wheelchairAccessible: boolean("wheelchair_accessible").notNull().default(false),
  
  // STRUCTURED COORDINATES (replacing jsonb catch-all)
  latitude: decimal("latitude", { precision: 10, scale: 8 }), // GPS latitude
  longitude: decimal("longitude", { precision: 11, scale: 8 }), // GPS longitude
  gpsAccuracy: integer("gps_accuracy"), // Accuracy in meters
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// ===================== CRITICAL SECURITY: ENCRYPTED ARTIFACTS TABLE =====================
// This table stores all sensitive data with application-layer envelope encryption
export const encryptedArtifacts = pgTable("encrypted_artifacts", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  
  // Reference Information
  entityType: text("entity_type").notNull(), // 'biometric', 'document', 'signature', 'personal_data'
  entityId: varchar("entity_id").notNull(), // ID of the entity this artifact belongs to
  artifactType: text("artifact_type").notNull(), // 'template_data', 'image', 'document_scan', 'signature'
  
  // Encrypted Data
  encryptedData: text("encrypted_data").notNull(), // Base64-encoded encrypted data
  encryptionAlgorithm: encryptionAlgorithmEnum("encryption_algorithm").notNull(),
  keyId: text("key_id").notNull(), // References the encryption key used
  iv: text("iv").notNull(), // Initialization vector for encryption
  salt: text("salt"), // Salt for key derivation if applicable
  
  // Digital Signature for Integrity
  digitalSignature: text("digital_signature").notNull(),
  signatureAlgorithm: signatureAlgorithmEnum("signature_algorithm").notNull(),
  signingKeyId: text("signing_key_id").notNull(),
  signatureFormat: text("signature_format").notNull().default("base64"), // 'base64', 'hex', 'der'
  
  // Access Control
  classificationLevel: classificationLevelEnum("classification_level").notNull().default("confidential"),
  accessControlList: jsonb("access_control_list").notNull(), // Who can decrypt this data
  
  // Metadata (non-sensitive)
  dataSize: integer("data_size").notNull(), // Size of original data in bytes
  compressionUsed: boolean("compression_used").notNull().default(false),
  compressionAlgorithm: text("compression_algorithm"), // 'gzip', 'lz4', etc.
  
  // Audit Trail
  createdBy: varchar("created_by").notNull().references(() => users.id),
  accessedBy: jsonb("accessed_by"), // Array of user IDs who accessed this data
  lastAccessedAt: timestamp("last_accessed_at"),
  accessCount: integer("access_count").notNull().default(0),
  
  // Compliance and Retention
  retentionPolicy: text("retention_policy"), // 'indefinite', '7_years', '10_years', etc.
  purgeDate: timestamp("purge_date"), // When this data should be purged
  popiaCategory: text("popia_category"), // POPIA data category for compliance
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Unique indexes for encryptedArtifacts (temporarily commented out due to compilation issue)
// export const encryptedArtifactsEntityIdx = uniqueIndex("encrypted_artifacts_entity_idx").on(encryptedArtifacts.entityType, encryptedArtifacts.entityId, encryptedArtifacts.artifactType);
// export const encryptedArtifactsKeyIdx = uniqueIndex("encrypted_artifacts_key_idx").on(encryptedArtifacts.keyId, encryptedArtifacts.createdAt);

// ===================== SECURE BIOMETRIC PROFILES =====================
// Updated to use encrypted storage for sensitive biometric data
export const biometricProfiles = pgTable("biometric_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  type: biometricTypeEnum("type").notNull(),
  
  // SECURITY FIX: No more plaintext biometric data
  // templateData is now stored in encryptedArtifacts table
  encryptedArtifactId: varchar("encrypted_artifact_id").notNull().references(() => encryptedArtifacts.id),
  
  // Non-sensitive metadata only
  quality: integer("quality").notNull(), // 0-100 quality score
  isVerified: boolean("is_verified").notNull().default(false),
  enrollmentDate: timestamp("enrollment_date").notNull().default(sql`now()`),
  lastUsed: timestamp("last_used"),
  isActive: boolean("is_active").notNull().default(true),
  
  // Template characteristics (non-sensitive)
  templateVersion: text("template_version").notNull().default("1.0"),
  algorithmUsed: text("algorithm_used"), // Algorithm used to create template
  qualityMetrics: jsonb("quality_metrics"), // Non-sensitive quality measurements
  
  // Audit and Compliance
  enrollmentMethod: text("enrollment_method"), // 'live_capture', 'import', 'mobile_app'
  enrollmentDevice: text("enrollment_device"), // Device identifier
  enrollmentLocation: text("enrollment_location"), // Office/location where enrolled
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Unique index for biometricProfiles: one biometric type per user
// export const biometricProfilesUserTypeIdx = uniqueIndex("biometric_profiles_user_type_idx").on(biometricProfiles.userId, biometricProfiles.type);

// ===================== NORMALIZED 8-STAGE DHA WORKFLOW SYSTEM =====================
// Workflow Stages - Master table defining the 8 official DHA stages
export const workflowStages = pgTable("workflow_stages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  stageCode: text("stage_code").notNull().unique(), // 'DRAFT', 'IDENTITY_VERIFICATION', etc.
  stageName: text("stage_name").notNull(),
  stageOrder: integer("stage_order").notNull(),
  description: text("description").notNull(),
  
  // Stage Configuration
  isRequired: boolean("is_required").notNull().default(true),
  canSkip: boolean("can_skip").notNull().default(false),
  requiresApproval: boolean("requires_approval").notNull().default(false),
  
  // SLA and Timing
  expectedDurationHours: integer("expected_duration_hours"),
  maxDurationHours: integer("max_duration_hours"),
  warningThresholdHours: integer("warning_threshold_hours"),
  
  // Automation Settings
  canAutomate: boolean("can_automate").notNull().default(false),
  automationRules: jsonb("automation_rules"),
  
  // Access Control
  requiredPermissions: jsonb("required_permissions"), // What permissions needed to work on this stage
  allowedRoles: jsonb("allowed_roles"), // Which roles can process this stage
  
  // Metadata
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Unique index for workflowStages: stage order must be unique
// export const workflowStagesOrderIdx = uniqueIndex("workflow_stages_order_idx").on(workflowStages.stageOrder);

// Workflow Transitions - Defines valid transitions between stages
export const workflowTransitions = pgTable("workflow_transitions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  fromStageId: varchar("from_stage_id").references(() => workflowStages.id),
  toStageId: varchar("to_stage_id").notNull().references(() => workflowStages.id),
  
  // Transition Rules
  transitionType: text("transition_type").notNull(), // 'normal', 'rejection', 'escalation', 'skip'
  isAutomated: boolean("is_automated").notNull().default(false),
  requiresApproval: boolean("requires_approval").notNull().default(false),
  
  // Conditions for transition
  transitionConditions: jsonb("transition_conditions"), // JSON rules for when this transition can occur
  requiredData: jsonb("required_data"), // What data must be present for transition
  
  // Business Rules
  businessRules: jsonb("business_rules"), // Business logic to validate transition
  validationRules: jsonb("validation_rules"), // Technical validation rules
  
  // Metadata
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Unique index for workflowTransitions: unique transition between stages
// export const workflowTransitionsIdx = uniqueIndex("workflow_transitions_idx").on(workflowTransitions.fromStageId, workflowTransitions.toStageId, workflowTransitions.transitionType);

// Document Workflow Instances - Tracks actual workflow execution for documents
export const documentWorkflowInstances = pgTable("document_workflow_instances", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  
  // Document and Application References
  documentId: varchar("document_id").notNull(),
  documentType: documentTypeEnum("document_type").notNull(),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Current State
  currentStageId: varchar("current_stage_id").notNull().references(() => workflowStages.id),
  workflowStatus: workflowStatusEnum("workflow_status").notNull().default("in_progress"),
  
  // Progress Tracking
  startedAt: timestamp("started_at").notNull().default(sql`now()`),
  completedAt: timestamp("completed_at"),
  estimatedCompletionAt: timestamp("estimated_completion_at"),
  
  // SLA Tracking
  totalElapsedHours: integer("total_elapsed_hours").default(0),
  slaBreached: boolean("sla_breached").notNull().default(false),
  slaBreachReason: text("sla_breach_reason"),
  
  // Priority and Escalation
  priorityLevel: priorityLevelEnum("priority_level").notNull().default("normal"),
  escalationLevel: text("escalation_level").default("none"), // 'none', 'supervisor', 'manager', 'director'
  escalationReason: text("escalation_reason"),
  escalatedAt: timestamp("escalated_at"),
  escalatedBy: varchar("escalated_by").references(() => users.id),
  
  // Assignment
  assignedTo: varchar("assigned_to").references(() => users.id),
  assignedAt: timestamp("assigned_at"),
  assignedBy: varchar("assigned_by").references(() => users.id),
  
  // Workflow Data
  workflowData: jsonb("workflow_data"), // All data collected throughout workflow
  stageResults: jsonb("stage_results"), // Results from each completed stage
  
  // Quality Control
  qualityChecksPassed: boolean("quality_checks_passed"),
  qualityIssues: jsonb("quality_issues"),
  qualityCheckedBy: varchar("quality_checked_by").references(() => users.id),
  qualityCheckedAt: timestamp("quality_checked_at"),
  
  // Final Results
  finalDecision: text("final_decision"), // 'approved', 'rejected', 'conditional'
  decisionReason: text("decision_reason"),
  decisionMadeBy: varchar("decision_made_by").references(() => users.id),
  decisionMadeAt: timestamp("decision_made_at"),
  
  // Document Issuance (for approved workflows)
  documentNumber: text("document_number"),
  issueDate: timestamp("issue_date"),
  expiryDate: timestamp("expiry_date"),
  issuedBy: varchar("issued_by").references(() => users.id),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Unique indexes for documentWorkflowInstances
// export const documentWorkflowInstancesDocIdx = uniqueIndex("document_workflow_instances_doc_idx").on(documentWorkflowInstances.documentId, documentWorkflowInstances.documentType);
// export const documentWorkflowInstancesAppIdx = uniqueIndex("document_workflow_instances_app_idx").on(documentWorkflowInstances.applicationId, documentWorkflowInstances.documentType);

// Workflow Stage Executions - Track execution of individual stages
export const workflowStageExecutions = pgTable("workflow_stage_executions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  workflowInstanceId: varchar("workflow_instance_id").notNull().references(() => documentWorkflowInstances.id),
  stageId: varchar("stage_id").notNull().references(() => workflowStages.id),
  
  // Execution Status
  executionStatus: text("execution_status").notNull().default("pending"), // 'pending', 'in_progress', 'completed', 'failed', 'skipped'
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  
  // Assignment and Processing
  assignedTo: varchar("assigned_to").references(() => users.id),
  processedBy: varchar("processed_by").references(() => users.id),
  
  // Results and Data
  stageResult: text("stage_result"), // 'passed', 'failed', 'requires_review'
  stageData: jsonb("stage_data"), // Data collected/processed in this stage
  stageScore: integer("stage_score"), // 0-100 score for this stage
  
  // Decision Information
  decision: text("decision"), // 'approve', 'reject', 'refer', 'hold'
  decisionReason: text("decision_reason"),
  reviewNotes: text("review_notes"),
  
  // Timing and SLA
  durationMinutes: integer("duration_minutes"),
  slaMetMinutes: integer("sla_met_minutes"), // Expected duration for this stage
  slaBreached: boolean("sla_breached").notNull().default(false),
  
  // Quality and Verification
  verificationRequired: boolean("verification_required").notNull().default(false),
  verificationStatus: text("verification_status"), // 'pending', 'verified', 'failed'
  verifiedBy: varchar("verified_by").references(() => users.id),
  verifiedAt: timestamp("verified_at"),
  
  // Error Handling
  errorCode: text("error_code"),
  errorMessage: text("error_message"),
  retryCount: integer("retry_count").notNull().default(0),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Unique index for workflowStageExecutions: one execution per workflow stage
// export const workflowStageExecutionsIdx = uniqueIndex("workflow_stage_executions_idx").on(workflowStageExecutions.workflowInstanceId, workflowStageExecutions.stageId);

export const apiKeys = pgTable("api_keys", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  keyHash: text("key_hash").notNull().unique(),
  name: text("name").notNull(),
  userId: varchar("user_id").references(() => users.id),
  permissions: jsonb("permissions"), // JSON array of permissions
  isActive: boolean("is_active").notNull().default(true),
  expiresAt: timestamp("expires_at"),
  lastUsed: timestamp("last_used"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const certificates = pgTable("certificates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  type: text("type").notNull(), // 'completion', 'achievement', 'compliance', etc.
  title: text("title").notNull(),
  description: text("description").notNull(),
  templateType: text("template_type").notNull(), // References document template
  data: jsonb("data"), // Certificate-specific data
  serialNumber: text("serial_number").notNull().unique(),
  issuedAt: timestamp("issued_at").notNull().default(sql`now()`),
  expiresAt: timestamp("expires_at"),
  status: text("status").notNull().default("active"), // 'active', 'suspended', 'expired'
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeUrl: text("qr_code_url"),
  documentUrl: text("document_url"),
  digitalSignature: text("digital_signature"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const permits = pgTable("permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  type: text("type").notNull(), // 'building', 'business', 'special_event', etc.
  title: text("title").notNull(),
  description: text("description").notNull(),
  templateType: text("template_type").notNull(), // References document template
  data: jsonb("data"), // Permit-specific data
  permitNumber: text("permit_number").notNull().unique(),
  issuedAt: timestamp("issued_at").notNull().default(sql`now()`),
  expiresAt: timestamp("expires_at"),
  status: text("status").notNull().default("active"), // 'active', 'suspended', 'expired'
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeUrl: text("qr_code_url"),
  documentUrl: text("document_url"),
  conditions: jsonb("conditions"), // Terms and conditions specific to permit
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const documentTemplates = pgTable("document_templates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  type: text("type").notNull(), // 'certificate', 'permit', 'birth_certificate', 'marriage_certificate', 'passport', 'death_certificate', 'work_permit', 'permanent_visa', 'id_card'
  htmlTemplate: text("html_template").notNull(),
  cssStyles: text("css_styles").notNull(),
  officialLayout: jsonb("official_layout"), // Layout configuration and styling options
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Birth Certificates
export const birthCertificates = pgTable("birth_certificates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  fullName: text("full_name").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  placeOfBirth: text("place_of_birth").notNull(),
  motherFullName: text("mother_full_name").notNull(),
  motherMaidenName: text("mother_maiden_name"),
  fatherFullName: text("father_full_name").notNull(),
  registrationNumber: text("registration_number").notNull().unique(),
  registrationDate: timestamp("registration_date").notNull().default(sql`now()`),
  issuingAuthority: text("issuing_authority").notNull(),
  officialSeal: text("official_seal"), // Seal image data or reference
  watermarkData: text("watermark_data"), // Security watermark information
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"), // Additional security metadata
  status: text("status").notNull().default("active"), // 'active', 'amended', 'revoked'
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Marriage Certificates
export const marriageCertificates = pgTable("marriage_certificates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  spouseOneFullName: text("spouse_one_full_name").notNull(),
  spouseOneDateOfBirth: timestamp("spouse_one_date_of_birth").notNull(),
  spouseOnePlaceOfBirth: text("spouse_one_place_of_birth").notNull(),
  spouseTwoFullName: text("spouse_two_full_name").notNull(),
  spouseTwoDateOfBirth: timestamp("spouse_two_date_of_birth").notNull(),
  spouseTwoPlaceOfBirth: text("spouse_two_place_of_birth").notNull(),
  marriageDate: timestamp("marriage_date").notNull(),
  marriagePlace: text("marriage_place").notNull(),
  witnessOneName: text("witness_one_name").notNull(),
  witnessTwoName: text("witness_two_name").notNull(),
  officiantName: text("officiant_name").notNull(),
  licenseNumber: text("license_number").notNull().unique(),
  registrationNumber: text("registration_number").notNull().unique(),
  issuingAuthority: text("issuing_authority").notNull(),
  officialSignatures: jsonb("official_signatures"), // Signatures data
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Passports
export const passports = pgTable("passports", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  passportNumber: text("passport_number").notNull().unique(),
  fullName: text("full_name").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  placeOfBirth: text("place_of_birth").notNull(),
  nationality: text("nationality").notNull(),
  sex: text("sex").notNull(),
  height: text("height"),
  eyeColor: text("eye_color"),
  issueDate: timestamp("issue_date").notNull().default(sql`now()`),
  expiryDate: timestamp("expiry_date").notNull(),
  issuingAuthority: text("issuing_authority").notNull(),
  placeOfIssue: text("place_of_issue").notNull(),
  photoUrl: text("photo_url"), // Passport photo reference
  signatureUrl: text("signature_url"), // Signature reference
  machineReadableZone: text("machine_readable_zone"), // MRZ data
  rfidChipData: text("rfid_chip_data"), // Simulated chip data
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Death Certificates
export const deathCertificates = pgTable("death_certificates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  deceasedFullName: text("deceased_full_name").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  dateOfDeath: timestamp("date_of_death").notNull(),
  placeOfDeath: text("place_of_death").notNull(),
  causeOfDeath: text("cause_of_death").notNull(),
  mannerOfDeath: text("manner_of_death"), // natural, accident, suicide, homicide, undetermined
  certifyingPhysician: text("certifying_physician").notNull(),
  medicalExaminerSignature: text("medical_examiner_signature"),
  registrationNumber: text("registration_number").notNull().unique(),
  registrationDate: timestamp("registration_date").notNull().default(sql`now()`),
  issuingAuthority: text("issuing_authority").notNull(),
  informantName: text("informant_name"), // Person who reported death
  relationshipToDeceased: text("relationship_to_deceased"),
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Work Permits
export const workPermits = pgTable("work_permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  employeeFullName: text("employee_full_name").notNull(),
  employeeNationality: text("employee_nationality").notNull(),
  employeePassportNumber: text("employee_passport_number").notNull(),
  employerName: text("employer_name").notNull(),
  employerAddress: text("employer_address").notNull(),
  jobTitle: text("job_title").notNull(),
  jobDescription: text("job_description"),
  workLocation: text("work_location").notNull(),
  permitNumber: text("permit_number").notNull().unique(),
  issueDate: timestamp("issue_date").notNull().default(sql`now()`),
  validFrom: timestamp("valid_from").notNull(),
  validUntil: timestamp("valid_until").notNull(),
  workRestrictions: jsonb("work_restrictions"), // Array of restrictions
  issuingAuthority: text("issuing_authority").notNull(),
  sponsorDetails: jsonb("sponsor_details"), // Sponsor information
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Permanent Visas
export const permanentVisas = pgTable("permanent_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  holderFullName: text("holder_full_name").notNull(),
  holderNationality: text("holder_nationality").notNull(),
  holderPassportNumber: text("holder_passport_number").notNull(),
  visaType: text("visa_type").notNull(), // family, employment, investment, refugee, etc.
  visaCategory: text("visa_category").notNull(),
  visaNumber: text("visa_number").notNull().unique(),
  issueDate: timestamp("issue_date").notNull().default(sql`now()`),
  validFrom: timestamp("valid_from").notNull(),
  expiryDate: timestamp("expiry_date"),
  countryOfIssue: text("country_of_issue").notNull(),
  issuingAuthority: text("issuing_authority").notNull(),
  portOfEntry: text("port_of_entry"),
  immigrationStamps: jsonb("immigration_stamps"), // Entry/exit stamps
  sponsorInformation: jsonb("sponsor_information"),
  photoUrl: text("photo_url"),
  fingerprintData: text("fingerprint_data"), // Biometric data reference
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// ID Cards
export const idCards = pgTable("id_cards", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  idNumber: text("id_number").notNull().unique(),
  fullName: text("full_name").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  placeOfBirth: text("place_of_birth").notNull(),
  sex: text("sex").notNull(),
  nationality: text("nationality").notNull(),
  address: text("address").notNull(),
  issueDate: timestamp("issue_date").notNull().default(sql`now()`),
  expiryDate: timestamp("expiry_date").notNull(),
  issuingAuthority: text("issuing_authority").notNull(),
  photoUrl: text("photo_url"),
  signatureUrl: text("signature_url"),
  rfidChipData: text("rfid_chip_data"), // Simulated chip data
  parentNames: text("parent_names"), // Combined parent information
  emergencyContact: jsonb("emergency_contact"),
  verificationCode: text("verification_code").notNull().unique(),
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  status: text("status").notNull().default("active"),
  isRevoked: boolean("is_revoked").notNull().default(false),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Document Verification Audit Trail
export const documentVerifications = pgTable("document_verifications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentType: text("document_type").notNull(), // 'birth_certificate', 'passport', etc.
  documentId: varchar("document_id").notNull(), // Reference to specific document
  verificationCode: text("verification_code").notNull(),
  verifierIpAddress: text("verifier_ip_address"),
  verifierUserAgent: text("verifier_user_agent"),
  verificationResult: text("verification_result").notNull(), // 'valid', 'invalid', 'expired', 'revoked'
  verificationDetails: jsonb("verification_details"), // Additional verification data
  verifiedAt: timestamp("verified_at").notNull().default(sql`now()`),
});

// Password strength validation
const passwordStrengthSchema = z.string()
  .min(8, "Password must be at least 8 characters long")
  .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, 
    "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character");

// Insert schemas
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  email: true,
  password: true,
  role: true,
}).extend({
  password: passwordStrengthSchema, // Override with strength validation
});

export const insertConversationSchema = createInsertSchema(conversations).pick({
  userId: true,
  title: true,
});

export const insertMessageSchema = createInsertSchema(messages).pick({
  conversationId: true,
  role: true,
  content: true,
  metadata: true,
});

export const insertDocumentSchema = createInsertSchema(documents).omit({
  id: true,
  createdAt: true,
});

export const insertSecurityEventSchema = createInsertSchema(securityEvents).omit({
  id: true,
  createdAt: true,
});

export const insertFraudAlertSchema = createInsertSchema(fraudAlerts).omit({
  id: true,
  createdAt: true,
  resolvedAt: true,
});

export const insertSystemMetricSchema = createInsertSchema(systemMetrics).omit({
  id: true,
});

export const insertQuantumKeySchema = createInsertSchema(quantumKeys).omit({
  id: true,
  createdAt: true,
});

export const insertErrorLogSchema = createInsertSchema(errorLogs).omit({
  id: true,
  timestamp: true,
  resolvedAt: true,
});

export const insertBiometricProfileSchema = createInsertSchema(biometricProfiles).omit({
  id: true,
  createdAt: true,
});

export const insertApiKeySchema = createInsertSchema(apiKeys).omit({
  id: true,
  createdAt: true,
});

export const insertCertificateSchema = createInsertSchema(certificates).omit({
  id: true,
  createdAt: true,
});

export const insertPermitSchema = createInsertSchema(permits).omit({
  id: true,
  createdAt: true,
});

export const insertDocumentTemplateSchema = createInsertSchema(documentTemplates).omit({
  id: true,
  createdAt: true,
});

export const insertBirthCertificateSchema = createInsertSchema(birthCertificates).omit({
  id: true,
  createdAt: true,
});

export const insertMarriageCertificateSchema = createInsertSchema(marriageCertificates).omit({
  id: true,
  createdAt: true,
});

export const insertPassportSchema = createInsertSchema(passports).omit({
  id: true,
  createdAt: true,
});

export const insertDeathCertificateSchema = createInsertSchema(deathCertificates).omit({
  id: true,
  createdAt: true,
});

export const insertWorkPermitSchema = createInsertSchema(workPermits).omit({
  id: true,
  createdAt: true,
});

export const insertPermanentVisaSchema = createInsertSchema(permanentVisas).omit({
  id: true,
  createdAt: true,
});

export const insertIdCardSchema = createInsertSchema(idCards).omit({
  id: true,
  createdAt: true,
});

export const insertDocumentVerificationSchema = createInsertSchema(documentVerifications).omit({
  id: true,
});

// New table insert schemas
export const insertRefugeeDocumentSchema = createInsertSchema(refugeeDocuments).omit({
  id: true,
  createdAt: true,
});

export const insertDiplomaticPassportSchema = createInsertSchema(diplomaticPassports).omit({
  id: true,
  createdAt: true,
});

export const insertDocumentDeliverySchema = createInsertSchema(documentDelivery).omit({
  id: true,
  createdAt: true,
});


export const insertDhaOfficeSchema = createInsertSchema(dhaOffices).omit({
  id: true,
  createdAt: true,
});

// AMS Certificate and Status Management insert schemas
export const insertAmsCertificateSchema = createInsertSchema(amsCertificates).omit({
  id: true,
  createdAt: true,
});

export const insertPermitStatusChangeSchema = createInsertSchema(permitStatusChanges).omit({
  id: true,
  createdAt: true,
});

export const insertDocumentVerificationStatusSchema = createInsertSchema(documentVerificationStatus).omit({
  id: true,
  createdAt: true,
});

export const insertLiveDocumentVerificationHistorySchema = createInsertSchema(liveDocumentVerificationHistory).omit({
  id: true,
  createdAt: true,
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Conversation = typeof conversations.$inferSelect;
export type InsertConversation = z.infer<typeof insertConversationSchema>;

export type Message = typeof messages.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;

export type Document = typeof documents.$inferSelect;
export type InsertDocument = z.infer<typeof insertDocumentSchema>;

export type SecurityEvent = typeof securityEvents.$inferSelect;
export type InsertSecurityEvent = z.infer<typeof insertSecurityEventSchema>;

export type FraudAlert = typeof fraudAlerts.$inferSelect;
export type InsertFraudAlert = z.infer<typeof insertFraudAlertSchema>;

export type SystemMetric = typeof systemMetrics.$inferSelect;
export type InsertSystemMetric = z.infer<typeof insertSystemMetricSchema>;

export type QuantumKey = typeof quantumKeys.$inferSelect;
export type InsertQuantumKey = z.infer<typeof insertQuantumKeySchema>;

export type ErrorLog = typeof errorLogs.$inferSelect;
export type InsertErrorLog = z.infer<typeof insertErrorLogSchema>;

export type BiometricProfile = typeof biometricProfiles.$inferSelect;
export type InsertBiometricProfile = z.infer<typeof insertBiometricProfileSchema>;

export type ApiKey = typeof apiKeys.$inferSelect;
export type InsertApiKey = z.infer<typeof insertApiKeySchema>;

export type Certificate = typeof certificates.$inferSelect;
export type InsertCertificate = z.infer<typeof insertCertificateSchema>;

export type Permit = typeof permits.$inferSelect;
export type InsertPermit = z.infer<typeof insertPermitSchema>;

export type DocumentTemplate = typeof documentTemplates.$inferSelect;
export type InsertDocumentTemplate = z.infer<typeof insertDocumentTemplateSchema>;

export type BirthCertificate = typeof birthCertificates.$inferSelect;
export type InsertBirthCertificate = z.infer<typeof insertBirthCertificateSchema>;

export type MarriageCertificate = typeof marriageCertificates.$inferSelect;
export type InsertMarriageCertificate = z.infer<typeof insertMarriageCertificateSchema>;

export type Passport = typeof passports.$inferSelect;
export type InsertPassport = z.infer<typeof insertPassportSchema>;

export type DeathCertificate = typeof deathCertificates.$inferSelect;
export type InsertDeathCertificate = z.infer<typeof insertDeathCertificateSchema>;

export type WorkPermit = typeof workPermits.$inferSelect;
export type InsertWorkPermit = z.infer<typeof insertWorkPermitSchema>;

export type PermanentVisa = typeof permanentVisas.$inferSelect;
export type InsertPermanentVisa = z.infer<typeof insertPermanentVisaSchema>;

export type IdCard = typeof idCards.$inferSelect;
export type InsertIdCard = z.infer<typeof insertIdCardSchema>;

export type DocumentVerification = typeof documentVerifications.$inferSelect;
export type InsertDocumentVerification = z.infer<typeof insertDocumentVerificationSchema>;

// New table types
export type RefugeeDocument = typeof refugeeDocuments.$inferSelect;
export type InsertRefugeeDocument = z.infer<typeof insertRefugeeDocumentSchema>;

export type DiplomaticPassport = typeof diplomaticPassports.$inferSelect;
export type InsertDiplomaticPassport = z.infer<typeof insertDiplomaticPassportSchema>;

export type DocumentDelivery = typeof documentDelivery.$inferSelect;
export type InsertDocumentDelivery = z.infer<typeof insertDocumentDeliverySchema>;


export type DhaOffice = typeof dhaOffices.$inferSelect;
export type InsertDhaOffice = z.infer<typeof insertDhaOfficeSchema>;

// AMS Certificate and Status Management types
export type AmsCertificate = typeof amsCertificates.$inferSelect;
export type InsertAmsCertificate = z.infer<typeof insertAmsCertificateSchema>;

export type PermitStatusChange = typeof permitStatusChanges.$inferSelect;
export type InsertPermitStatusChange = z.infer<typeof insertPermitStatusChangeSchema>;

export type DocumentVerificationStatus = typeof documentVerificationStatus.$inferSelect;
export type InsertDocumentVerificationStatus = z.infer<typeof insertDocumentVerificationStatusSchema>;

// ===================== DHA SOUTH AFRICA INTEGRATION TABLES =====================

// DHA Applicants - Personal details and citizenship information
export const dhaApplicants = pgTable("dha_applicants", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  
  // Personal Information
  fullName: text("full_name").notNull(),
  surNames: text("sur_names").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  placeOfBirth: text("place_of_birth").notNull(),
  countryOfBirth: text("country_of_birth").notNull(),
  sex: text("sex").notNull(), // 'M', 'F', 'X'
  nationality: text("nationality").notNull(),
  
  // Contact Information
  residentialAddress: text("residential_address").notNull(),
  postalAddress: text("postal_address"),
  phoneNumber: text("phone_number").notNull(),
  emailAddress: text("email_address").notNull().unique(), // UNIQUE CONSTRAINT ADDED
  
  // Identity Information - WITH PRODUCTION CONSTRAINTS
  idNumber: text("id_number").unique(), // South African ID number - UNIQUE CONSTRAINT ADDED
  passportNumber: text("passport_number").unique(), // Current passport number - UNIQUE CONSTRAINT ADDED
  previousPassportNumbers: text("previous_passport_numbers").array(), // Array of previous passport numbers - STRUCTURED
  
  // Citizenship Status
  citizenshipStatus: text("citizenship_status").notNull(), // 'citizen', 'permanent_resident', 'refugee', 'asylum_seeker'
  citizenshipAcquisitionDate: timestamp("citizenship_acquisition_date"),
  citizenshipAcquisitionMethod: text("citizenship_acquisition_method"), // 'birth', 'naturalization', 'descent'
  
  // Parents Information
  motherFullName: text("mother_full_name"),
  motherMaidenName: text("mother_maiden_name"),
  motherIdNumber: text("mother_id_number"),
  fatherFullName: text("father_full_name"),
  fatherIdNumber: text("father_id_number"),
  
  // Biometric Information
  biometricTemplates: jsonb("biometric_templates"), // Fingerprint, facial recognition templates
  biometricQualityScores: jsonb("biometric_quality_scores"),
  
  // Document Information
  photoUrl: text("photo_url"),
  signatureUrl: text("signature_url"),
  
  // Verification Status
  isVerified: boolean("is_verified").notNull().default(false),
  verificationScore: integer("verification_score"),
  verificationNotes: text("verification_notes"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
}, (table) => ({
  // ===================== PRODUCTION CONSTRAINTS AND VALIDATIONS =====================
  // Check constraint for South African ID number format (13 digits)
  saIdFormatCheck: check("sa_id_format", sql`${table.idNumber} IS NULL OR ${table.idNumber} ~ '^[0-9]{13}$'`),
  // Check constraint for passport number format (Letter + 8 digits) 
  passportFormatCheck: check("passport_format", sql`${table.passportNumber} IS NULL OR ${table.passportNumber} ~ '^[A-Z][0-9]{8}$'`),
  // Check constraint for email format
  emailFormatCheck: check("email_format", sql`${table.emailAddress} ~ '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'`),
  // Check constraint for phone number format (SA format: +27 or 0 followed by 9 digits)
  phoneFormatCheck: check("phone_format", sql`${table.phoneNumber} ~ '^(\\+27|0)[0-9]{9}$'`),
  // Check constraint for gender values
  genderCheck: check("gender_check", sql`${table.sex} IN ('M', 'F', 'X')`),
  // Check constraint for citizenship status
  citizenshipCheck: check("citizenship_check", sql`${table.citizenshipStatus} IN ('citizen', 'permanent_resident', 'refugee', 'asylum_seeker')`),
}));

// DHA Applications - Permit/certificate applications with workflow states
export const dhaApplications = pgTable("dha_applications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  
  // Application Details
  applicationType: text("application_type").notNull(), // 'passport', 'id_document', 'visa', 'permit', 'certificate'
  applicationSubtype: text("application_subtype"), // 'renewal', 'replacement', 'new', 'amendment'
  applicationNumber: text("application_number").notNull().unique(),
  
  // DHA Workflow States
  currentState: text("current_state").notNull().default("draft"), 
  // States: draft  identity_verification  eligibility_check  background_verification  payment_processing  adjudication  approved  issued  active
  previousStates: jsonb("previous_states"), // Array of state history with timestamps
  
  // Application Data
  applicationData: jsonb("application_data").notNull(), // Form data specific to application type
  documentsSubmitted: jsonb("documents_submitted"), // References to uploaded documents
  
  // Processing Information
  priorityLevel: text("priority_level").notNull().default("standard"), // 'urgent', 'standard', 'low'
  processingFee: integer("processing_fee"), // Fee in cents
  paymentStatus: text("payment_status").default("pending"), // 'pending', 'paid', 'refunded', 'failed'
  paymentReference: text("payment_reference"),
  
  // DHA Officer Assignment
  assignedOfficer: text("assigned_officer"),
  assignedOffice: text("assigned_office"),
  assignedDate: timestamp("assigned_date"),
  
  // Verification Results
  identityVerificationResult: text("identity_verification_result"), // 'passed', 'failed', 'pending'
  eligibilityCheckResult: text("eligibility_check_result"),
  backgroundVerificationResult: text("background_verification_result"),
  
  // Decision Information
  decisionStatus: text("decision_status"), // 'approved', 'rejected', 'pending'
  decisionDate: timestamp("decision_date"),
  decisionReason: text("decision_reason"),
  decisionNotes: text("decision_notes"),
  
  // Issuance Information
  issuedDocumentNumber: text("issued_document_number"),
  issuedDate: timestamp("issued_date"),
  expiryDate: timestamp("expiry_date"),
  
  // Collection Information
  collectionMethod: text("collection_method"), // 'office', 'courier', 'post'
  collectionOffice: text("collection_office"),
  collectionDate: timestamp("collection_date"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// DHA Verifications - Record of NPR, ABIS, SAPS, PKD verification results
export const dhaVerifications = pgTable("dha_verifications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  applicationId: varchar("application_id").notNull().references(() => dhaApplications.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  
  // Verification Type and Service
  verificationType: text("verification_type").notNull(), // 'npr', 'abis', 'saps_crc', 'icao_pkd', 'mrz'
  verificationService: text("verification_service").notNull(), // External service used
  verificationMethod: text("verification_method"), // Specific method within service
  
  // Request Information
  requestId: text("request_id").notNull().unique(), // External service request ID
  requestData: jsonb("request_data"), // Data sent to external service
  requestTimestamp: timestamp("request_timestamp").notNull().default(sql`now()`),
  
  // Response Information
  responseStatus: text("response_status").notNull(), // 'success', 'failed', 'timeout', 'error'
  responseData: jsonb("response_data"), // Full response from external service
  responseTimestamp: timestamp("response_timestamp"),
  responseTime: integer("response_time"), // Response time in milliseconds
  
  // Verification Results
  verificationResult: text("verification_result"), // 'verified', 'not_verified', 'inconclusive'
  confidenceScore: integer("confidence_score"), // 0-100 confidence in verification
  matchScore: integer("match_score"), // 0-100 match score for biometric verifications
  
  // NPR Specific Fields
  nprPersonId: text("npr_person_id"), // NPR person identifier
  nprMatchLevel: text("npr_match_level"), // 'exact', 'probable', 'possible'
  
  // ABIS Specific Fields
  abisMatchId: text("abis_match_id"), // ABIS match identifier
  abisBiometricType: text("abis_biometric_type"), // 'fingerprint', 'facial', 'iris'
  
  // SAPS CRC Specific Fields
  sapsReferenceNumber: text("saps_reference_number"),
  sapsClearanceStatus: text("saps_clearance_status"), // 'clear', 'pending', 'record_found'
  
  // PKD Specific Fields
  pkdCertificateStatus: text("pkd_certificate_status"), // 'valid', 'invalid', 'revoked', 'expired'
  pkdIssuerCountry: text("pkd_issuer_country"),
  pkdCertificateSerial: text("pkd_certificate_serial"),
  
  // MRZ Specific Fields
  mrzValidationResult: text("mrz_validation_result"), // 'valid', 'invalid', 'checksum_failed'
  mrzParsedData: jsonb("mrz_parsed_data"),
  
  // Error Information
  errorCode: text("error_code"),
  errorMessage: text("error_message"),
  errorDetails: jsonb("error_details"),
  
  // Retry Information
  retryCount: integer("retry_count").notNull().default(0),
  lastRetryAt: timestamp("last_retry_at"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// DHA Audit Events - Complete audit trail of all DHA interactions
export const dhaAuditEvents = pgTable("dha_audit_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  
  // Entity References
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  applicantId: varchar("applicant_id").references(() => dhaApplicants.id),
  userId: varchar("user_id").references(() => users.id),
  
  // Event Information
  eventType: text("event_type").notNull(), // 'application_submitted', 'state_changed', 'verification_completed', etc.
  eventCategory: text("event_category").notNull(), // 'system', 'user', 'external_service', 'administrative'
  eventDescription: text("event_description").notNull(),
  
  // Actor Information
  actorType: text("actor_type").notNull(), // 'user', 'system', 'dha_officer', 'external_service'
  actorId: text("actor_id"), // ID of the actor (user ID, service name, etc.)
  actorName: text("actor_name"), // Human-readable name of actor
  
  // Context Information
  contextData: jsonb("context_data"), // Additional context about the event
  beforeState: jsonb("before_state"), // State before the event
  afterState: jsonb("after_state"), // State after the event
  
  // Request Information
  requestSource: text("request_source"), // 'web', 'mobile', 'api', 'batch_process'
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  sessionId: text("session_id"),
  
  // Compliance Information
  complianceFlags: jsonb("compliance_flags"), // POPIA and other compliance markers
  dataProcessingPurpose: text("data_processing_purpose"), // Legal basis for processing
  
  // Metadata
  timestamp: timestamp("timestamp").notNull().default(sql`now()`),
});

// DHA Consent Records - POPIA compliance for background checks and data processing
export const dhaConsentRecords = pgTable("dha_consent_records", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Consent Information
  consentType: text("consent_type").notNull(), // 'data_processing', 'background_check', 'biometric_capture', 'information_sharing'
  consentPurpose: text("consent_purpose").notNull(), // Specific purpose for which consent is given
  consentScope: jsonb("consent_scope"), // Detailed scope of what is consented to
  
  // Legal Basis
  legalBasis: text("legal_basis").notNull(), // POPIA legal basis - 'consent', 'legitimate_interest', 'legal_obligation', etc.
  lawfulnessAssessment: text("lawfulness_assessment"), // Documentation of lawfulness assessment
  
  // Consent Details
  consentText: text("consent_text").notNull(), // Full text of consent given
  consentVersion: text("consent_version").notNull(), // Version of consent document
  consentLanguage: text("consent_language").notNull().default("en"), // Language in which consent was given
  
  // Consent Status
  consentStatus: text("consent_status").notNull().default("given"), // 'given', 'withdrawn', 'expired'
  consentMethod: text("consent_method").notNull(), // 'digital_signature', 'checkbox', 'verbal', 'written'
  
  // Timing Information
  consentGivenAt: timestamp("consent_given_at").notNull().default(sql`now()`),
  consentExpiresAt: timestamp("consent_expires_at"),
  consentWithdrawnAt: timestamp("consent_withdrawn_at"),
  
  // Evidence
  consentEvidence: jsonb("consent_evidence"), // Digital signature, IP address, etc.
  consentWitness: text("consent_witness"), // Witness to consent if applicable
  
  // Data Subject Rights
  dataSubjectNotified: boolean("data_subject_notified").notNull().default(true),
  dataSubjectRights: jsonb("data_subject_rights"), // Rights explained to data subject
  withdrawalMethod: text("withdrawal_method"), // How consent can be withdrawn
  
  // Processing Information
  processingStartDate: timestamp("processing_start_date"),
  processingEndDate: timestamp("processing_end_date"),
  dataRetentionPeriod: text("data_retention_period"),
  
  // Compliance
  popiaCompliant: boolean("popia_compliant").notNull().default(true),
  complianceNotes: text("compliance_notes"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// DHA Background Checks - SAPS criminal record check results
export const dhaBackgroundChecks = pgTable("dha_background_checks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").notNull().references(() => dhaApplications.id),
  verificationId: varchar("verification_id").references(() => dhaVerifications.id),
  
  // Check Information
  checkType: text("check_type").notNull(), // 'criminal_record', 'credit_check', 'employment_verification', 'reference_check'
  checkProvider: text("check_provider").notNull(), // 'saps', 'credit_bureau', 'employer', etc.
  checkReference: text("check_reference").notNull().unique(), // External reference number
  
  // Request Information
  requestedBy: varchar("requested_by").notNull().references(() => users.id),
  requestDate: timestamp("request_date").notNull().default(sql`now()`),
  requestReason: text("request_reason").notNull(),
  
  // Consent Information
  consentRecordId: varchar("consent_record_id").references(() => dhaConsentRecords.id),
  consentGiven: boolean("consent_given").notNull(),
  consentDate: timestamp("consent_date"),
  
  // Results
  checkStatus: text("check_status").notNull().default("pending"), // 'pending', 'completed', 'failed', 'cancelled'
  resultStatus: text("result_status"), // 'clear', 'records_found', 'inconclusive'
  
  // SAPS Criminal Record Specific
  sapsPolicyNumber: text("saps_policy_number"), // SAPS policy clearance number
  sapsResultCode: text("saps_result_code"),
  sapsResultDescription: text("saps_result_description"),
  criminalRecords: jsonb("criminal_records"), // Array of criminal record details
  
  // General Results
  checkResults: jsonb("check_results"), // Full results from check provider
  riskAssessment: text("risk_assessment"), // 'low', 'medium', 'high'
  riskFactors: jsonb("risk_factors"), // Identified risk factors
  
  // Processing Information
  processingStartDate: timestamp("processing_start_date"),
  processingCompletedDate: timestamp("processing_completed_date"),
  processingDuration: integer("processing_duration"), // Duration in hours
  
  // Validity
  validFromDate: timestamp("valid_from_date"),
  validUntilDate: timestamp("valid_until_date"),
  isExpired: boolean("is_expired").notNull().default(false),
  
  // Quality Assurance
  verifiedBy: varchar("verified_by").references(() => users.id),
  verificationDate: timestamp("verification_date"),
  verificationNotes: text("verification_notes"),
  
  // Appeal Information
  appealable: boolean("appealable").notNull().default(true),
  appealDeadline: timestamp("appeal_deadline"),
  appealSubmitted: boolean("appeal_submitted").notNull().default(false),
  appealOutcome: text("appeal_outcome"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// ===================== DHA INSERT SCHEMAS =====================

export const insertDhaApplicantSchema = createInsertSchema(dhaApplicants).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertDhaApplicationSchema = createInsertSchema(dhaApplications).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertDhaVerificationSchema = createInsertSchema(dhaVerifications).omit({
  id: true,
  createdAt: true,
});

export const insertDhaAuditEventSchema = createInsertSchema(dhaAuditEvents).omit({
  id: true,
});

export const insertDhaConsentRecordSchema = createInsertSchema(dhaConsentRecords).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertDhaBackgroundCheckSchema = createInsertSchema(dhaBackgroundChecks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// ===================== DHA TYPES =====================

export type DhaApplicant = typeof dhaApplicants.$inferSelect;
export type InsertDhaApplicant = z.infer<typeof insertDhaApplicantSchema>;

export type DhaApplication = typeof dhaApplications.$inferSelect;
export type InsertDhaApplication = z.infer<typeof insertDhaApplicationSchema>;

export type DhaVerification = typeof dhaVerifications.$inferSelect;
export type InsertDhaVerification = z.infer<typeof insertDhaVerificationSchema>;

export type DhaAuditEvent = typeof dhaAuditEvents.$inferSelect;
export type InsertDhaAuditEvent = z.infer<typeof insertDhaAuditEventSchema>;

export type DhaConsentRecord = typeof dhaConsentRecords.$inferSelect;
export type InsertDhaConsentRecord = z.infer<typeof insertDhaConsentRecordSchema>;

export type DhaBackgroundCheck = typeof dhaBackgroundChecks.$inferSelect;
export type InsertDhaBackgroundCheck = z.infer<typeof insertDhaBackgroundCheckSchema>;

// ===================== ADDITIONAL INSERT SCHEMAS FOR API VALIDATION =====================

// User update schema for admin endpoints
export const updateUserSchema = z.object({
  username: z.string().min(1).optional(),
  email: z.string().email().optional(),
  role: z.enum(["user", "admin"]).optional(),
  isActive: z.boolean().optional(),
});

// User profile update schema
export const userProfileUpdateSchema = z.object({
  username: z.string().min(3, "Username must be at least 3 characters").max(50).optional(),
  email: z.string().email("Invalid email format").optional(),
});

// Change password schema
export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, "Current password is required"),
  newPassword: passwordStrengthSchema,
  confirmPassword: z.string().min(1, "Password confirmation is required")
}).refine((data) => data.newPassword === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

// Password reset request schema
export const passwordResetRequestSchema = z.object({
  email: z.string().email("Invalid email format"),
});

// Password reset schema
export const passwordResetSchema = z.object({
  token: z.string().min(1, "Reset token is required"),
  newPassword: passwordStrengthSchema,
  confirmPassword: z.string().min(1, "Password confirmation is required")
}).refine((data) => data.newPassword === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

// Document verification schema for admin endpoints
export const adminDocumentVerificationSchema = z.object({
  isApproved: z.boolean(),
  notes: z.string().optional(),
});

// Production backup schema
export const productionBackupSchema = z.object({
  backupType: z.enum(["full", "incremental"]).default("incremental"),
});

// Document template schema for admin endpoints
export const documentTemplateSchema = z.object({
  name: z.string().min(1),
  type: z.enum(["certificate", "permit"]),
  htmlTemplate: z.string().min(1),
  cssStyles: z.string().min(1),
  officialLayout: z.record(z.any()).optional().default({}),
});

// DHA application creation schema
export const dhaApplicationCreationSchema = z.object({
  applicantId: z.string().min(1),
  applicationType: z.string().min(1),
  applicationData: z.record(z.any()).optional().default({}),
});

// DHA identity verification schema
export const dhaIdentityVerificationSchema = z.object({
  applicantId: z.string().min(1),
  applicationId: z.string().min(1),
  idNumber: z.string().min(1),
  fullName: z.string().min(1),
  dateOfBirth: z.string().optional(),
  placeOfBirth: z.string().optional(),
});

// DHA passport verification schema
export const dhaPassportVerificationSchema = z.object({
  applicantId: z.string().min(1),
  applicationId: z.string().min(1),
  mrzLine1: z.string().min(1),
  mrzLine2: z.string().min(1),
  passportImage: z.string().optional(),
});

// DHA background check schema
export const dhaBackgroundCheckCreationSchema = z.object({
  applicantId: z.string().min(1),
  applicationId: z.string().min(1),
  purpose: z.string().min(1),
  consentGiven: z.boolean(),
});

// DHA application transition schema
export const dhaApplicationTransitionSchema = z.object({
  targetState: z.string().min(1),
  reason: z.string().optional(),
  data: z.record(z.any()).optional(),
});

// Note: insertSecurityEventSchema is already defined above

// ===================== MISSING DOCUMENT TYPES FOR COMPREHENSIVE DHA SYSTEM =====================

// South African Smart ID Cards
export const southAfricanIds = pgTable("south_african_ids", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Identity Information
  idNumber: text("id_number").notNull().unique(),
  fullName: text("full_name").notNull(),
  surname: text("surname").notNull(),
  firstNames: text("first_names").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  placeOfBirth: text("place_of_birth").notNull(),
  gender: text("gender").notNull(), // 'M', 'F'
  nationality: text("nationality").notNull().default("South African"),
  maritalStatus: text("marital_status"), // 'Single', 'Married', 'Divorced', 'Widowed'
  
  // Physical Characteristics
  eyeColor: text("eye_color"),
  hairColor: text("hair_color"),
  height: text("height"),
  identifyingMarks: text("identifying_marks"),
  
  // Address Information
  residentialAddress: jsonb("residential_address"),
  postalAddress: jsonb("postal_address"),
  
  // Card Information
  cardNumber: text("card_number").unique(),
  cardVersion: text("card_version").default("Smart ID"),
  chipSerial: text("chip_serial"),
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date"),
  issuingOffice: text("issuing_office").notNull(),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  biometricTemplate: text("biometric_template"),
  
  // Status and Validity
  status: text("status").notNull().default("active"), // 'active', 'suspended', 'cancelled', 'replaced'
  replacementReason: text("replacement_reason"),
  previousIdNumber: text("previous_id_number"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Study Permits
export const studyPermits = pgTable("study_permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Permit Information
  permitNumber: text("permit_number").notNull().unique(),
  permitType: text("permit_type").notNull().default("study"),
  section: text("section"), // Section of Immigration Act
  
  // Applicant Details
  passportNumber: text("passport_number").notNull(),
  nationality: text("nationality").notNull(),
  
  // Study Information
  institutionName: text("institution_name").notNull(),
  institutionAddress: jsonb("institution_address"),
  institutionRegistration: text("institution_registration"),
  courseName: text("course_name").notNull(),
  courseLevel: text("course_level"), // 'Certificate', 'Diploma', 'Degree', 'Postgraduate', 'PhD'
  courseDuration: text("course_duration"),
  fieldOfStudy: text("field_of_study"),
  studyStartDate: timestamp("study_start_date").notNull(),
  studyEndDate: timestamp("study_end_date").notNull(),
  
  // Financial Information
  tuitionFees: integer("tuition_fees"),
  livingExpenses: integer("living_expenses"),
  financialProof: jsonb("financial_proof"),
  sponsorDetails: jsonb("sponsor_details"),
  
  // Permit Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  validForReEntry: boolean("valid_for_re_entry").default(false),
  
  // Conditions and Endorsements
  conditions: jsonb("conditions"), // Study permit conditions
  endorsements: jsonb("endorsements"),
  workRights: boolean("work_rights").default(false),
  maxWorkHours: integer("max_work_hours"),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Business Permits
export const businessPermits = pgTable("business_permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Permit Information
  permitNumber: text("permit_number").notNull().unique(),
  permitType: text("permit_type").notNull().default("business"),
  businessCategory: text("business_category"), // 'General Business', 'Investor', 'Self-Employment'
  
  // Business Information
  businessName: text("business_name").notNull(),
  businessRegistration: text("business_registration"),
  businessType: text("business_type"), // 'CC', 'Pty Ltd', 'Partnership', 'Sole Proprietor'
  businessAddress: jsonb("business_address"),
  businessSector: text("business_sector"),
  businessDescription: text("business_description"),
  
  // Investment Information
  investmentAmount: integer("investment_amount"),
  capitalInvestment: integer("capital_investment"),
  jobCreationPlan: text("job_creation_plan"),
  expectedEmployment: integer("expected_employment"),
  
  // Financial Requirements
  businessPlan: text("business_plan_url"),
  financialStatements: jsonb("financial_statements"),
  bankingDetails: jsonb("banking_details"),
  
  // Permit Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  
  // Conditions and Endorsements
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  geographicLimitations: text("geographic_limitations"),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Visitor's Visas
export const visitorsVisas = pgTable("visitors_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  visaType: text("visa_type").notNull().default("visitor"),
  visaCategory: text("visa_category"), // 'Tourism', 'Business', 'Family Visit', 'Medical', 'Conference'
  entries: text("entries"), // 'Single', 'Multiple'
  
  // Visit Information
  purposeOfVisit: text("purpose_of_visit").notNull(),
  intendedDuration: integer("intended_duration"), // Days
  arrivalDate: timestamp("arrival_date"),
  departureDate: timestamp("departure_date"),
  
  // Accommodation
  accommodationType: text("accommodation_type"), // 'Hotel', 'Guest House', 'Private', 'Other'
  accommodationAddress: jsonb("accommodation_address"),
  accommodationContact: jsonb("accommodation_contact"),
  
  // Sponsor/Host Information
  sponsorDetails: jsonb("sponsor_details"),
  hostDetails: jsonb("host_details"),
  relationshipToSponsor: text("relationship_to_sponsor"),
  
  // Financial Support
  financialSupport: jsonb("financial_support"),
  dailyExpenditure: integer("daily_expenditure"),
  totalFunds: integer("total_funds"),
  
  // Travel Information
  entryPoint: text("entry_point"),
  exitPoint: text("exit_point"),
  transportMode: text("transport_mode"), // 'Air', 'Land', 'Sea'
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  validFrom: timestamp("valid_from").notNull(),
  validUntil: timestamp("valid_until").notNull(),
  
  // Conditions and Endorsements
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  workProhibited: boolean("work_prohibited").default(true),
  studyProhibited: boolean("study_prohibited").default(true),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Transit Visas
export const transitVisas = pgTable("transit_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  transitType: text("transit_type").notNull(), // 'Airport', 'Land', 'Seaport'
  transitDuration: integer("transit_duration"), // Hours
  
  // Travel Information
  originCountry: text("origin_country").notNull(),
  destinationCountry: text("destination_country").notNull(),
  transitRoute: jsonb("transit_route"),
  flightDetails: jsonb("flight_details"),
  
  // Timing
  arrivalDateTime: timestamp("arrival_date_time").notNull(),
  departureDateTime: timestamp("departure_date_time").notNull(),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  validFrom: timestamp("valid_from").notNull(),
  validUntil: timestamp("valid_until").notNull(),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Medical Treatment Visas
export const medicalTreatmentVisas = pgTable("medical_treatment_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  treatmentType: text("treatment_type"), // 'Surgery', 'Therapy', 'Consultation', 'Emergency'
  urgencyLevel: text("urgency_level"), // 'Routine', 'Urgent', 'Emergency'
  
  // Medical Information
  medicalCondition: text("medical_condition").notNull(),
  treatmentDescription: text("treatment_description").notNull(),
  treatmentDuration: integer("treatment_duration"), // Days
  doctorRecommendation: text("doctor_recommendation"),
  
  // Healthcare Provider
  hospitalName: text("hospital_name").notNull(),
  hospitalAddress: jsonb("hospital_address"),
  hospitalRegistration: text("hospital_registration"),
  doctorDetails: jsonb("doctor_details"),
  
  // Treatment Schedule
  treatmentStartDate: timestamp("treatment_start_date").notNull(),
  treatmentEndDate: timestamp("treatment_end_date").notNull(),
  appointmentSchedule: jsonb("appointment_schedule"),
  
  // Financial Arrangements
  treatmentCost: integer("treatment_cost"),
  paymentMethod: text("payment_method"), // 'Self-funded', 'Medical Insurance', 'Government', 'NGO'
  insuranceDetails: jsonb("insurance_details"),
  
  // Accompanying Persons
  accompaniedBy: jsonb("accompanied_by"), // Family members, caregivers
  caregiverDetails: jsonb("caregiver_details"),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  validFrom: timestamp("valid_from").notNull(),
  validUntil: timestamp("valid_until").notNull(),
  
  // Conditions
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  extensionAllowed: boolean("extension_allowed").default(true),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Critical Skills Visas
export const criticalSkillsVisas = pgTable("critical_skills_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  skillsCategory: text("skills_category").notNull(), // From critical skills list
  professionalBody: text("professional_body"), // SAICA, ECSA, HPCSA, etc.
  registrationNumber: text("registration_number"),
  
  // Professional Qualifications
  qualificationTitle: text("qualification_title").notNull(),
  qualificationLevel: text("qualification_level"), // Degree, Masters, PhD, Professional
  institutionName: text("institution_name").notNull(),
  qualificationCountry: text("qualification_country").notNull(),
  saqa_evaluation: text("saqa_evaluation"), // SAQA evaluation reference
  
  // Professional Experience
  workExperience: integer("work_experience"), // Years of experience
  currentPosition: text("current_position"),
  currentEmployer: text("current_employer"),
  employmentHistory: jsonb("employment_history"),
  
  // Skills Assessment
  skillsAssessment: text("skills_assessment_url"),
  assessingBody: text("assessing_body"),
  assessmentDate: timestamp("assessment_date"),
  assessmentValidUntil: timestamp("assessment_valid_until"),
  
  // Job Offer (if applicable)
  jobOfferLetter: text("job_offer_letter_url"),
  employerName: text("employer_name"),
  employerAddress: jsonb("employer_address"),
  jobTitle: text("job_title"),
  salaryOffered: integer("salary_offered"),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  
  // Rights and Conditions
  workRights: boolean("work_rights").default(true),
  studyRights: boolean("study_rights").default(false),
  businessRights: boolean("business_rights").default(false),
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Intra-Company Transfer Visas
export const intraCompanyTransferVisas = pgTable("intra_company_transfer_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  transferType: text("transfer_type"), // 'Manager', 'Executive', 'Specialist Knowledge'
  
  // Home Company Information
  homeCompanyName: text("home_company_name").notNull(),
  homeCompanyAddress: jsonb("home_company_address"),
  homeCompanyRegistration: text("home_company_registration"),
  homeCountry: text("home_country").notNull(),
  
  // SA Company Information
  saCompanyName: text("sa_company_name").notNull(),
  saCompanyAddress: jsonb("sa_company_address"),
  saCompanyRegistration: text("sa_company_registration"),
  
  // Company Relationship
  relationshipType: text("relationship_type"), // 'Subsidiary', 'Branch', 'Affiliate', 'Parent'
  ownershipPercentage: integer("ownership_percentage"),
  relationshipEvidence: text("relationship_evidence_url"),
  
  // Employment Details
  currentPosition: text("current_position").notNull(),
  proposedPosition: text("proposed_position").notNull(),
  transferDuration: integer("transfer_duration"), // Months
  employmentPeriod: integer("employment_period"), // Months with home company
  
  // Qualifications and Experience
  qualifications: jsonb("qualifications"),
  specialistKnowledge: text("specialist_knowledge"),
  managerialExperience: text("managerial_experience"),
  
  // Transfer Details
  transferStartDate: timestamp("transfer_start_date").notNull(),
  transferEndDate: timestamp("transfer_end_date").notNull(),
  transferPurpose: text("transfer_purpose"),
  
  // Financial Information
  salary: integer("salary"),
  allowances: jsonb("allowances"),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  
  // Conditions
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  workRights: boolean("work_rights").default(true),
  changeEmployerAllowed: boolean("change_employer_allowed").default(false),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Corporate Visas
export const corporateVisas = pgTable("corporate_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  corporateCategory: text("corporate_category"), // 'Executive', 'Senior Management', 'Board Member'
  
  // Corporate Entity Information
  corporateName: text("corporate_name").notNull(),
  corporateRegistration: text("corporate_registration"),
  corporateAddress: jsonb("corporate_address"),
  corporateType: text("corporate_type"), // 'Multinational', 'Listed Company', 'Private Company'
  
  // SA Business Operations
  saBranchOffice: text("sa_branch_office"),
  saRegistrationNumber: text("sa_registration_number"),
  businessActivity: text("business_activity"),
  sectorOfOperation: text("sector_of_operation"),
  
  // Investment Information
  investmentAmount: integer("investment_amount"),
  jobCreationPlan: text("job_creation_plan"),
  expectedEmployees: integer("expected_employees"),
  economicImpact: text("economic_impact"),
  
  // Applicant Role
  positionTitle: text("position_title").notNull(),
  jobDescription: text("job_description"),
  reportingStructure: jsonb("reporting_structure"),
  authorityLevel: text("authority_level"),
  
  // Team and Operations
  teamSize: integer("team_size"),
  budgetResponsibility: integer("budget_responsibility"),
  businessUnitSize: integer("business_unit_size"),
  
  // Qualifications
  educationBackground: jsonb("education_background"),
  professionalExperience: jsonb("professional_experience"),
  managementExperience: integer("management_experience"), // Years
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  
  // Rights and Conditions
  workRights: boolean("work_rights").default(true),
  businessRights: boolean("business_rights").default(true),
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Treaty Visas
export const treatyVisas = pgTable("treaty_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  treatyReference: text("treaty_reference").notNull(), // Specific treaty reference
  treatyType: text("treaty_type"), // 'Bilateral Agreement', 'Trade Agreement', 'Investment Treaty'
  
  // Treaty Information
  treatyName: text("treaty_name").notNull(),
  signatoryCountries: text().array(),
  treatyArticle: text("treaty_article"), // Specific article under which visa is granted
  treatyProvisions: jsonb("treaty_provisions"),
  
  // Applicant's Country Status
  citizenshipCountry: text("citizenship_country").notNull(),
  treatyEligibility: text("treaty_eligibility"),
  countryStatus: text("country_status"), // 'Signatory', 'Most Favored Nation', etc.
  
  // Purpose and Activities
  treatyPurpose: text("treaty_purpose").notNull(),
  businessActivities: jsonb("business_activities"),
  investmentDetails: jsonb("investment_details"),
  tradeActivities: jsonb("trade_activities"),
  
  // Business Information
  businessName: text("business_name"),
  businessType: text("business_type"),
  businessAddress: jsonb("business_address"),
  businessRegistration: text("business_registration"),
  
  // Investment Information
  investmentAmount: integer("investment_amount"),
  investmentType: text("investment_type"), // 'Direct', 'Portfolio', 'Joint Venture'
  investmentSector: text("investment_sector"),
  jobCreation: integer("job_creation"),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date"),
  renewableUnderTreaty: boolean("renewable_under_treaty").default(true),
  
  // Rights and Conditions
  workRights: boolean("work_rights").default(true),
  businessRights: boolean("business_rights").default(true),
  investmentRights: boolean("investment_rights").default(true),
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Temporary Residence Permits
export const temporaryResidencePermits = pgTable("temporary_residence_permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Permit Information
  permitNumber: text("permit_number").notNull().unique(),
  permitCategory: text("permit_category").notNull(), // 'General Work', 'Spousal', 'Life Partner', 'Relative'
  section: text("section"), // Section of Immigration Act
  
  // Basis for Permit
  permitBasis: text("permit_basis").notNull(), // 'Employment', 'Relationship', 'Investment', 'Study Continuation'
  eligibilityCriteria: jsonb("eligibility_criteria"),
  
  // Employment Information (if applicable)
  employerName: text("employer_name"),
  employerAddress: jsonb("employer_address"),
  jobTitle: text("job_title"),
  jobDescription: text("job_description"),
  salary: integer("salary"),
  employmentContract: text("employment_contract_url"),
  
  // Relationship Information (if applicable)
  relationshipType: text("relationship_type"), // 'Spouse', 'Life Partner', 'Child'
  partnerDetails: jsonb("partner_details"),
  relationshipProof: jsonb("relationship_proof"),
  dependents: jsonb("dependents"),
  
  // Sponsor Information
  sponsorIdNumber: text("sponsor_id_number"),
  sponsorStatus: text("sponsor_status"), // 'SA Citizen', 'Permanent Resident'
  sponsorEmployment: jsonb("sponsor_employment"),
  sponsorIncome: integer("sponsor_income"),
  
  // Accommodation
  residentialAddress: jsonb("residential_address"),
  accommodationProof: text("accommodation_proof_url"),
  accommodationType: text("accommodation_type"), // 'Own', 'Rental', 'Family'
  
  // Permit Validity and Conditions
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  renewalEligible: boolean("renewal_eligible").default(true),
  maxRenewals: integer("max_renewals"),
  renewalCount: integer("renewal_count").default(0),
  
  // Rights and Conditions
  workRights: boolean("work_rights").default(false),
  studyRights: boolean("study_rights").default(false),
  businessRights: boolean("business_rights").default(false),
  geographicRestrictions: text("geographic_restrictions"),
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  
  // Path to Permanent Residence
  prEligible: boolean("pr_eligible").default(false),
  prEligibilityDate: timestamp("pr_eligibility_date"),
  continuousResidenceRequired: boolean("continuous_residence_required").default(true),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// ===================== ADDITIONAL TYPES =====================

export type UpdateUser = z.infer<typeof updateUserSchema>;
export type DocumentVerificationRequest = z.infer<typeof documentVerificationSchema>;
export type ProductionBackup = z.infer<typeof productionBackupSchema>;
export type DocumentTemplateRequest = z.infer<typeof documentTemplateSchema>;
export type DhaApplicationCreation = z.infer<typeof dhaApplicationCreationSchema>;
export type DhaIdentityVerification = z.infer<typeof dhaIdentityVerificationSchema>;
export type DhaPassportVerification = z.infer<typeof dhaPassportVerificationSchema>;
export type DhaBackgroundCheckCreation = z.infer<typeof dhaBackgroundCheckCreationSchema>;
export type DhaApplicationTransition = z.infer<typeof dhaApplicationTransitionSchema>;

// ===================== 8-STAGE PROCESSING WORKFLOW SYSTEM =====================

// Document Processing Workflow - Enhanced 8-stage system
export const documentProcessingWorkflow = pgTable("document_processing_workflow", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull(),
  documentType: text("document_type").notNull(),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Current Workflow State
  currentStage: text("current_stage").notNull().default("draft"), 
  // Stages: 'draft', 'identity_verification', 'eligibility_check', 'background_verification', 'payment', 'adjudication', 'approved', 'issued'
  workflowStatus: text("workflow_status").notNull().default("in_progress"), // 'in_progress', 'completed', 'rejected', 'on_hold', 'cancelled'
  
  // Stage 1: Draft
  draftStatus: text("draft_status").default("pending"), // 'pending', 'submitted', 'validated'
  draftSubmittedAt: timestamp("draft_submitted_at"),
  draftValidatedBy: varchar("draft_validated_by").references(() => users.id),
  draftValidatedAt: timestamp("draft_validated_at"),
  draftValidationNotes: text("draft_validation_notes"),
  applicationData: jsonb("application_data"), // Complete application form data
  supportingDocuments: jsonb("supporting_documents"), // URLs and metadata of uploaded docs
  
  // Stage 2: Identity Verification
  identityVerificationStatus: text("identity_verification_status").default("pending"), // 'pending', 'in_progress', 'verified', 'failed'
  nprVerificationResult: jsonb("npr_verification_result"),
  biometricVerificationResult: jsonb("biometric_verification_result"),
  documentAuthenticityCheck: jsonb("document_authenticity_check"),
  identityScore: integer("identity_score"), // 0-100
  identityVerifiedBy: varchar("identity_verified_by").references(() => users.id),
  identityVerifiedAt: timestamp("identity_verified_at"),
  identityVerificationNotes: text("identity_verification_notes"),
  
  // Stage 3: Eligibility Check
  eligibilityCheckStatus: text("eligibility_check_status").default("pending"), // 'pending', 'in_progress', 'eligible', 'ineligible'
  eligibilityCriteria: jsonb("eligibility_criteria"), // Specific criteria for document type
  eligibilityAssessment: jsonb("eligibility_assessment"), // Results of each criterion check
  eligibilityScore: integer("eligibility_score"), // 0-100
  eligibilityCheckedBy: varchar("eligibility_checked_by").references(() => users.id),
  eligibilityCheckedAt: timestamp("eligibility_checked_at"),
  eligibilityNotes: text("eligibility_notes"),
  
  // Stage 4: Background Verification
  backgroundVerificationStatus: text("background_verification_status").default("pending"), // 'pending', 'in_progress', 'cleared', 'flagged'
  sapsCheckResult: jsonb("saps_check_result"),
  creditCheckResult: jsonb("credit_check_result"),
  employmentVerificationResult: jsonb("employment_verification_result"),
  educationVerificationResult: jsonb("education_verification_result"),
  backgroundRiskScore: integer("background_risk_score"), // 0-100
  backgroundVerifiedBy: varchar("background_verified_by").references(() => users.id),
  backgroundVerifiedAt: timestamp("background_verified_at"),
  backgroundVerificationNotes: text("background_verification_notes"),
  
  // Stage 5: Payment
  paymentStatus: text("payment_status").default("pending"), // 'pending', 'processing', 'paid', 'failed', 'refunded'
  paymentAmount: integer("payment_amount"),
  paymentCurrency: text("payment_currency").default("ZAR"),
  paymentMethod: text("payment_method"), // 'card', 'eft', 'cash', 'bank_transfer'
  paymentReference: text("payment_reference"),
  paymentDate: timestamp("payment_date"),
  paymentProcessedBy: varchar("payment_processed_by").references(() => users.id),
  paymentNotes: text("payment_notes"),
  
  // Stage 6: Adjudication
  adjudicationStatus: text("adjudication_status").default("pending"), // 'pending', 'in_review', 'approved', 'rejected', 'requires_senior_review'
  adjudicationLevel: text("adjudication_level"), // 'junior_officer', 'senior_officer', 'manager', 'director'
  adjudicatedBy: varchar("adjudicated_by").references(() => users.id),
  adjudicatedAt: timestamp("adjudicated_at"),
  adjudicationDecision: text("adjudication_decision"), // 'approved', 'rejected', 'conditional_approval'
  adjudicationReason: text("adjudication_reason"),
  conditions: jsonb("conditions"), // Any conditions attached to approval
  seniorReviewRequired: boolean("senior_review_required").default(false),
  seniorReviewBy: varchar("senior_review_by").references(() => users.id),
  seniorReviewAt: timestamp("senior_review_at"),
  
  // Stage 7: Approved
  approvalStatus: text("approval_status").default("pending"), // 'pending', 'approved', 'conditional'
  approvedBy: varchar("approved_by").references(() => users.id),
  approvedAt: timestamp("approved_at"),
  approvalReference: text("approval_reference"),
  finalConditions: jsonb("final_conditions"),
  approvalNotes: text("approval_notes"),
  
  // Stage 8: Issued
  issuanceStatus: text("issuance_status").default("pending"), // 'pending', 'generating', 'ready', 'issued', 'delivered'
  documentGenerated: boolean("document_generated").default(false),
  documentGeneratedAt: timestamp("document_generated_at"),
  documentGeneratedBy: varchar("document_generated_by").references(() => users.id),
  documentNumber: text("document_number"),
  issueDate: timestamp("issue_date"),
  expiryDate: timestamp("expiry_date"),
  deliveryMethod: text("delivery_method"), // 'collection', 'courier', 'post'
  deliveryStatus: text("delivery_status"), // 'pending', 'in_transit', 'delivered', 'returned'
  deliveryDate: timestamp("delivery_date"),
  issuedBy: varchar("issued_by").references(() => users.id),
  
  // Security and Verification
  securityClassification: text("security_classification").default("official"), // 'unclassified', 'official', 'confidential', 'secret'
  verificationCode: text("verification_code").unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  documentHash: text("document_hash"),
  securityFeatures: jsonb("security_features"),
  
  // Workflow Metadata
  totalProcessingTime: integer("total_processing_time"), // Minutes from start to finish
  estimatedCompletionDate: timestamp("estimated_completion_date"),
  actualCompletionDate: timestamp("actual_completion_date"),
  slaBreached: boolean("sla_breached").default(false),
  priorityLevel: text("priority_level").default("normal"), // 'low', 'normal', 'high', 'urgent'
  escalationLevel: text("escalation_level").default("none"), // 'none', 'supervisor', 'manager', 'director'
  
  // Quality Control
  qualityCheckRequired: boolean("quality_check_required").default(true),
  qualityCheckStatus: text("quality_check_status"), // 'pending', 'passed', 'failed'
  qualityCheckedBy: varchar("quality_checked_by").references(() => users.id),
  qualityCheckedAt: timestamp("quality_checked_at"),
  qualityIssues: jsonb("quality_issues"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Workflow Stage Transitions - Track movement between stages
export const workflowStageTransitions = pgTable("workflow_stage_transitions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  workflowId: varchar("workflow_id").notNull().references(() => documentProcessingWorkflow.id),
  fromStage: text("from_stage"),
  toStage: text("to_stage").notNull(),
  transitionReason: text("transition_reason"),
  transitionData: jsonb("transition_data"), // Additional data about the transition
  triggeredBy: varchar("triggered_by").references(() => users.id),
  triggeredBySystem: boolean("triggered_by_system").default(false),
  automated: boolean("automated").default(false),
  transitionDate: timestamp("transition_date").notNull().default(sql`now()`),
  notes: text("notes"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// Document Classification System - Government security levels
export const documentClassifications = pgTable("document_classifications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull(),
  documentType: text("document_type").notNull(),
  classificationLevel: text("classification_level").notNull(), // 'unclassified', 'official', 'confidential', 'secret', 'top_secret'
  classificationReason: text("classification_reason"),
  classifiedBy: varchar("classified_by").notNull().references(() => users.id),
  classificationDate: timestamp("classification_date").notNull().default(sql`now()`),
  declassificationDate: timestamp("declassification_date"),
  accessControlList: jsonb("access_control_list"), // Who can access this classified document
  handlingInstructions: text("handling_instructions"),
  distributionLimitations: text("distribution_limitations"),
  caveats: jsonb("caveats"), // Special access requirements
  downgradingInstructions: text("downgrading_instructions"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// Enhanced Fraud Detection and Risk Analysis
export const fraudDetectionAnalysis = pgTable("fraud_detection_analysis", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  documentId: varchar("document_id").notNull(),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  workflowId: varchar("workflow_id").references(() => documentProcessingWorkflow.id),
  
  // Risk Scoring
  overallRiskScore: integer("overall_risk_score").notNull(), // 0-100
  riskLevel: text("risk_level").notNull(), // 'low', 'medium', 'high', 'critical'
  riskCategory: text("risk_category"), // 'identity_fraud', 'document_forgery', 'application_fraud', 'behavioral_anomaly'
  
  // Identity Fraud Detection
  identityRiskScore: integer("identity_risk_score"),
  duplicateIdentityFlags: jsonb("duplicate_identity_flags"),
  biometricAnomalies: jsonb("biometric_anomalies"),
  identityPatternAnalysis: jsonb("identity_pattern_analysis"),
  
  // Document Fraud Detection
  documentRiskScore: integer("document_risk_score"),
  documentTamperingIndicators: jsonb("document_tampering_indicators"),
  documentForensicAnalysis: jsonb("document_forensic_analysis"),
  securityFeatureValidation: jsonb("security_feature_validation"),
  
  // Application Fraud Detection
  applicationRiskScore: integer("application_risk_score"),
  dataInconsistencies: jsonb("data_inconsistencies"),
  crossReferenceValidation: jsonb("cross_reference_validation"),
  historicalPatternAnalysis: jsonb("historical_pattern_analysis"),
  
  // Behavioral Analysis
  behavioralRiskScore: integer("behavioral_risk_score"),
  userBehaviorAnalysis: jsonb("user_behavior_analysis"),
  accessPatterns: jsonb("access_patterns"),
  deviceFingerprinting: jsonb("device_fingerprinting"),
  
  // Machine Learning Analysis
  mlModelResults: jsonb("ml_model_results"),
  mlConfidenceScore: integer("ml_confidence_score"),
  mlModelVersion: text("ml_model_version"),
  featureImportance: jsonb("feature_importance"),
  
  // Analysis Metadata
  analysisDate: timestamp("analysis_date").notNull().default(sql`now()`),
  analysisVersion: text("analysis_version").default("1.0"),
  analyzerSystem: text("analyzer_system"), // 'ai_engine', 'rule_engine', 'hybrid'
  reviewRequired: boolean("review_required").default(false),
  reviewedBy: varchar("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  
  // Actions Taken
  actionsTaken: jsonb("actions_taken"), // Automated actions like flagging, blocking
  alertsGenerated: jsonb("alerts_generated"),
  investigationRequired: boolean("investigation_required").default(false),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// ===================== MISSING DOCUMENT TYPES (EXCHANGE PERMITS & RELATIVES VISAS) =====================

// Exchange Permits (if not already included)
export const exchangePermits = pgTable("exchange_permits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Permit Information
  permitNumber: text("permit_number").notNull().unique(),
  exchangeType: text("exchange_type"), // 'Academic', 'Cultural', 'Professional', 'Youth'
  programName: text("program_name").notNull(),
  
  // Exchange Program Details
  organizingInstitution: text("organizing_institution").notNull(),
  partnerInstitution: text("partner_institution").notNull(),
  programDescription: text("program_description"),
  exchangeDuration: integer("exchange_duration"), // Months
  
  // Academic/Professional Information
  fieldOfStudy: text("field_of_study"),
  professionalArea: text("professional_area"),
  qualificationLevel: text("qualification_level"),
  languageRequirements: jsonb("language_requirements"),
  
  // Program Dates
  programStartDate: timestamp("program_start_date").notNull(),
  programEndDate: timestamp("program_end_date").notNull(),
  
  // Supervision
  supervisorDetails: jsonb("supervisor_details"),
  mentorInformation: jsonb("mentor_information"),
  
  // Financial Arrangements
  stipendAmount: integer("stipend_amount"),
  fundingSource: text("funding_source"), // 'Government', 'Institution', 'Private', 'Self-funded'
  financialSponsor: jsonb("financial_sponsor"),
  
  // Permit Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date").notNull(),
  
  // Conditions
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  workRights: boolean("work_rights").default(false),
  studyRights: boolean("study_rights").default(true),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// Relative's Visas (if not already included) 
export const relativesVisas = pgTable("relatives_visas", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  applicantId: varchar("applicant_id").notNull().references(() => dhaApplicants.id),
  applicationId: varchar("application_id").references(() => dhaApplications.id),
  
  // Visa Information
  visaNumber: text("visa_number").notNull().unique(),
  relationshipType: text("relationship_type").notNull(), // 'Spouse', 'Child', 'Parent', 'Sibling'
  visaCategory: text("visa_category").notNull(), // 'Relative', 'Joining Family', 'Spousal'
  
  // Sponsor Information (SA Citizen/Resident)
  sponsorIdNumber: text("sponsor_id_number").notNull(),
  sponsorFullName: text("sponsor_full_name").notNull(),
  sponsorStatus: text("sponsor_status").notNull(), // 'SA Citizen', 'Permanent Resident', 'Work Permit Holder'
  sponsorProofOfStatus: text("sponsor_proof_of_status"),
  sponsorAddress: jsonb("sponsor_address"),
  sponsorEmployment: jsonb("sponsor_employment"),
  
  // Relationship Evidence
  relationshipProof: jsonb("relationship_proof"), // Marriage cert, birth cert, etc.
  marriageDate: timestamp("marriage_date"),
  marriagePlace: text("marriage_place"),
  marriageCertificateNumber: text("marriage_certificate_number"),
  relationshipDuration: integer("relationship_duration"), // Months
  
  // Living Arrangements
  intendedAddress: jsonb("intended_address"),
  accommodationDetails: jsonb("accommodation_details"),
  supportDetails: jsonb("support_details"),
  
  // Children (if applicable)
  dependentChildren: jsonb("dependent_children"),
  childrenSchooling: jsonb("children_schooling"),
  
  // Financial Support
  sponsorIncome: integer("sponsor_income"),
  supportCapacity: text("support_capacity"),
  financialCommitment: text("financial_commitment"),
  
  // Visa Validity
  issueDate: timestamp("issue_date").notNull(),
  expiryDate: timestamp("expiry_date"),
  
  // Conditions
  conditions: jsonb("conditions"),
  endorsements: jsonb("endorsements"),
  workRights: boolean("work_rights").default(false),
  studyRights: boolean("study_rights").default(false),
  
  // Security Features
  verificationCode: text("verification_code").notNull().unique(),
  qrCodeData: text("qr_code_data"),
  digitalSignature: text("digital_signature"),
  securityFeatures: jsonb("security_features"),
  
  // Status
  status: text("status").notNull().default("active"),
  
  // Document URLs
  documentUrl: text("document_url"),
  qrCodeUrl: text("qr_code_url"),
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at")
});

// ===================== ENHANCED NOTIFICATION SYSTEM =====================

// Notification Events - Comprehensive real-time notification system
export const notificationEvents = pgTable("notification_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id), // null for system-wide notifications
  category: text("category").notNull(), // 'system', 'security', 'document', 'user', 'admin', 'fraud', 'biometric'
  eventType: text("event_type").notNull(), // standardized event type naming
  priority: text("priority").notNull(), // 'low', 'medium', 'high', 'critical'
  title: text("title").notNull(),
  message: text("message").notNull(),
  payload: jsonb("payload"), // Additional event data
  isRead: boolean("is_read").notNull().default(false),
  isArchived: boolean("is_archived").notNull().default(false),
  requiresAction: boolean("requires_action").notNull().default(false), // Whether user needs to take action
  actionUrl: text("action_url"), // URL for action button
  actionLabel: text("action_label"), // Label for action button
  expiresAt: timestamp("expires_at"), // For time-sensitive notifications
  relatedEntityType: text("related_entity_type"), // 'document', 'application', 'user', etc.
  relatedEntityId: varchar("related_entity_id"), // ID of related entity
  createdBy: varchar("created_by").references(() => users.id), // System user or admin who created
  deliveredAt: timestamp("delivered_at"), // When notification was delivered
  readAt: timestamp("read_at"), // When notification was read
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// User Notification Preferences - Allow users to configure notification settings
export const userNotificationPreferences = pgTable("user_notification_preferences", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id).unique(),
  emailNotifications: boolean("email_notifications").notNull().default(true),
  pushNotifications: boolean("push_notifications").notNull().default(true),
  smsNotifications: boolean("sms_notifications").notNull().default(false),
  categories: jsonb("categories").notNull().default(sql`'{
    "system": {"enabled": true, "priority": "medium"},
    "security": {"enabled": true, "priority": "high"},
    "document": {"enabled": true, "priority": "high"},
    "fraud": {"enabled": true, "priority": "critical"},
    "biometric": {"enabled": true, "priority": "medium"},
    "admin": {"enabled": true, "priority": "medium"}
  }'`), // Category-specific preferences
  quietHours: jsonb("quiet_hours"), // {"start": "22:00", "end": "06:00", "enabled": true}
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// Real-time Status Updates - Track live status changes for various entities
export const statusUpdates = pgTable("status_updates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  entityType: text("entity_type").notNull(), // 'document', 'application', 'biometric_scan', 'system_health', etc.
  entityId: varchar("entity_id").notNull(),
  previousStatus: text("previous_status"),
  currentStatus: text("current_status").notNull(),
  statusDetails: jsonb("status_details"), // Additional status information
  progressPercentage: integer("progress_percentage"), // 0-100 for progress tracking
  estimatedCompletion: timestamp("estimated_completion"), // When process is expected to complete
  userId: varchar("user_id").references(() => users.id), // Associated user
  updatedBy: varchar("updated_by").references(() => users.id), // Who triggered the update
  isPublic: boolean("is_public").notNull().default(false), // Whether status is visible to users
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// WebSocket Connection Sessions - Track active WebSocket connections
export const webSocketSessions = pgTable("websocket_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  socketId: text("socket_id").notNull().unique(),
  sessionData: jsonb("session_data"), // Browser info, device info, etc.
  subscribedEvents: jsonb("subscribed_events").notNull().default('[]'), // Array of event types user subscribed to
  lastSeen: timestamp("last_seen").notNull().default(sql`now()`),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Live Chat Sessions - Real-time chat support system
export const chatSessions = pgTable("chat_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  adminId: varchar("admin_id").references(() => users.id), // Assigned admin support agent
  sessionType: text("session_type").notNull().default("support"), // 'support', 'document_review', 'verification'
  status: text("status").notNull().default("active"), // 'active', 'waiting', 'closed', 'escalated'
  priority: text("priority").notNull().default("medium"), // 'low', 'medium', 'high', 'urgent'
  subject: text("subject"), // Chat topic/subject
  metadata: jsonb("metadata"), // Additional session data
  lastMessageAt: timestamp("last_message_at").notNull().default(sql`now()`),
  closedAt: timestamp("closed_at"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Chat Messages - Messages within chat sessions
export const chatMessages = pgTable("chat_messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  chatSessionId: varchar("chat_session_id").notNull().references(() => chatSessions.id),
  senderId: varchar("sender_id").notNull().references(() => users.id),
  messageType: text("message_type").notNull().default("text"), // 'text', 'file', 'system', 'action'
  content: text("content").notNull(),
  metadata: jsonb("metadata"), // File info, system action info, etc.
  isRead: boolean("is_read").notNull().default(false),
  readAt: timestamp("read_at"),
  editedAt: timestamp("edited_at"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// ===================== NOTIFICATION SCHEMAS =====================

export const insertNotificationEventSchema = createInsertSchema(notificationEvents).omit({
  id: true,
  createdAt: true,
  readAt: true,
  deliveredAt: true,
});

// System notification schema for admin-to-users broadcasts
export const systemNotificationSchema = insertNotificationEventSchema.extend({
  targetRole: z.enum(["admin", "user"]).optional(), // Target role for broadcast
}).omit({ userId: true, createdBy: true }); // These will be set by the server

// Critical alert schema for urgent notifications
export const criticalAlertSchema = insertNotificationEventSchema.extend({
  alertType: z.string().min(1),
  requiresImmediateAction: z.boolean().default(true),
  escalationLevel: z.enum(["low", "medium", "high", "critical"]).default("critical")
}).omit({ userId: true, createdBy: true, priority: true }); // Priority is auto-set to critical

export const insertUserNotificationPreferencesSchema = createInsertSchema(userNotificationPreferences).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertStatusUpdateSchema = createInsertSchema(statusUpdates).omit({
  id: true,
  createdAt: true,
});

export const insertWebSocketSessionSchema = createInsertSchema(webSocketSessions).omit({
  id: true,
  createdAt: true,
});

export const insertChatSessionSchema = createInsertSchema(chatSessions).omit({
  id: true,
  createdAt: true,
});

export const insertChatMessageSchema = createInsertSchema(chatMessages).omit({
  id: true,
  createdAt: true,
  readAt: true,
  editedAt: true,
});

// Update notification preferences schema
export const updateNotificationPreferencesSchema = z.object({
  emailNotifications: z.boolean().optional(),
  pushNotifications: z.boolean().optional(),
  smsNotifications: z.boolean().optional(),
  categories: z.record(z.object({
    enabled: z.boolean(),
    priority: z.enum(["low", "medium", "high", "critical"])
  })).optional(),
  quietHours: z.object({
    start: z.string(),
    end: z.string(),
    enabled: z.boolean()
  }).optional(),
});

// ===================== NOTIFICATION TYPES =====================

export type NotificationEvent = typeof notificationEvents.$inferSelect;
export type InsertNotificationEvent = z.infer<typeof insertNotificationEventSchema>;
export type SystemNotification = z.infer<typeof systemNotificationSchema>;
export type CriticalAlert = z.infer<typeof criticalAlertSchema>;

export type UserNotificationPreferences = typeof userNotificationPreferences.$inferSelect;
export type InsertUserNotificationPreferences = z.infer<typeof insertUserNotificationPreferencesSchema>;
export type UpdateNotificationPreferences = z.infer<typeof updateNotificationPreferencesSchema>;

export type StatusUpdate = typeof statusUpdates.$inferSelect;
export type InsertStatusUpdate = z.infer<typeof insertStatusUpdateSchema>;

export type WebSocketSession = typeof webSocketSessions.$inferSelect;
export type InsertWebSocketSession = z.infer<typeof insertWebSocketSessionSchema>;

export type ChatSession = typeof chatSessions.$inferSelect;
export type InsertChatSession = z.infer<typeof insertChatSessionSchema>;

export type ChatMessage = typeof chatMessages.$inferSelect;
export type InsertChatMessage = z.infer<typeof insertChatMessageSchema>;

// ===================== STANDARDIZED EVENT TYPES =====================

export const NotificationCategory = {
  SYSTEM: 'system',
  SECURITY: 'security', 
  DOCUMENT: 'document',
  USER: 'user',
  ADMIN: 'admin',
  FRAUD: 'fraud',
  BIOMETRIC: 'biometric',
} as const;

export const NotificationPriority = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  CRITICAL: 'critical',
} as const;

export const EventType = {
  // System events
  SYSTEM_HEALTH_ALERT: 'system.health_alert',
  SYSTEM_MAINTENANCE: 'system.maintenance',
  SYSTEM_UPDATE: 'system.update',
  SYSTEM_DOWNTIME: 'system.downtime',
  
  // Security events  
  SECURITY_BREACH: 'security.breach',
  SECURITY_LOGIN: 'security.login',
  SECURITY_FAILED_LOGIN: 'security.failed_login',
  SECURITY_PASSWORD_CHANGED: 'security.password_changed',
  SECURITY_SUSPICIOUS_ACTIVITY: 'security.suspicious_activity',
  
  // Document events
  DOCUMENT_UPLOADED: 'document.uploaded',
  DOCUMENT_PROCESSING: 'document.processing',
  DOCUMENT_PROCESSED: 'document.processed',
  DOCUMENT_VERIFIED: 'document.verified',
  DOCUMENT_REJECTED: 'document.rejected',
  DOCUMENT_EXPIRED: 'document.expired',
  PROCESSING_FAILED: 'processing.failed',
  PROCESSING_COMPLETED: 'processing.completed',
  
  // User events
  USER_REGISTERED: 'user.registered',
  USER_PROFILE_UPDATED: 'user.profile_updated',
  USER_ACCOUNT_LOCKED: 'user.account_locked',
  USER_ACCOUNT_UNLOCKED: 'user.account_unlocked',
  
  // Admin events
  ADMIN_REVIEW_REQUIRED: 'admin.review_required',
  ADMIN_ACTION_COMPLETED: 'admin.action_completed',
  ADMIN_ESCALATION: 'admin.escalation',
  
  // Fraud events
  FRAUD_DETECTED: 'fraud.detected',
  FRAUD_RESOLVED: 'fraud.resolved',
  FRAUD_HIGH_RISK: 'fraud.high_risk',
  
  // Biometric events
  BIOMETRIC_ENROLLED: 'biometric.enrolled',
  BIOMETRIC_VERIFIED: 'biometric.verified',
  BIOMETRIC_FAILED: 'biometric.failed',
  BIOMETRIC_UPDATED: 'biometric.updated',
} as const;

// ===================== COMPREHENSIVE DOCUMENT VERIFICATION SYSTEM =====================

// Document Verification Records - Centralized verification system for all 21 DHA document types
export const documentVerificationRecords = pgTable("document_verification_records", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  verificationCode: text("verification_code").notNull().unique(), // 12-character verification code
  documentHash: text("document_hash").notNull(), // SHA-256 hash of document data
  documentType: documentTypeEnum("document_type").notNull(), // All 21 DHA document types
  documentNumber: text("document_number").notNull(), // Document reference number
  documentData: jsonb("document_data").notNull(), // Complete document information
  userId: varchar("user_id").references(() => users.id), // Document holder (optional)
  applicantId: varchar("applicant_id").references(() => dhaApplicants.id), // Associated applicant
  
  // Verification Details
  verificationUrl: text("verification_url").notNull(), // QR code verification URL
  hashtags: text("hashtags").array().notNull().default(sql`'{}'`), // Document hashtags for social verification
  isActive: boolean("is_active").notNull().default(true), // Whether document is active
  verificationCount: integer("verification_count").notNull().default(0), // Number of times verified
  lastVerifiedAt: timestamp("last_verified_at"), // Last verification timestamp
  
  // Document Metadata
  issuedAt: timestamp("issued_at").notNull().default(sql`now()`), // When document was issued
  expiryDate: timestamp("expiry_date"), // Document expiry date
  issuingOffice: text("issuing_office"), // Issuing office name
  issuingOfficer: text("issuing_officer"), // Issuing officer name
  
  // Security Features
  securityFeatures: jsonb("security_features").notNull().default('{}'), // Security feature metadata
  digitalSignature: text("digital_signature"), // Cryptographic signature
  encryptionLevel: text("encryption_level").default("AES-256"), // Encryption standard used
  
  // AI and Fraud Detection
  aiAuthenticityScore: integer("ai_authenticity_score"), // AI-calculated authenticity score (0-100)
  aiVerificationMetadata: jsonb("ai_verification_metadata"), // AI analysis results
  fraudRiskLevel: text("fraud_risk_level").default("low"), // low, medium, high, critical
  antiTamperHash: text("anti_tamper_hash"), // Hash for tampering detection
  
  // Revocation and Status
  revokedAt: timestamp("revoked_at"), // When document was revoked
  revocationReason: text("revocation_reason"), // Reason for revocation
  replacementDocumentId: varchar("replacement_document_id"), // If replaced, ID of new document
  
  // Metadata
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Document Verification History - Comprehensive audit trail of all verification attempts
export const documentVerificationHistory = pgTable("document_verification_history", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  verificationRecordId: varchar("verification_record_id").notNull().references(() => documentVerificationRecords.id),
  verificationMethod: text("verification_method").notNull(), // qr_scan, manual_entry, document_lookup, batch, api
  
  // Request Information
  requesterInfo: jsonb("requester_info"), // Information about who requested verification
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  location: jsonb("location"), // Geographic location data
  deviceFingerprint: text("device_fingerprint"), // Unique device identifier
  
  // Verification Results
  isSuccessful: boolean("is_successful").notNull(),
  confidenceLevel: integer("confidence_level"), // Verification confidence (0-100)
  verificationScore: integer("verification_score"), // Overall verification score
  
  // Cross-validation Results
  nprValidationResult: jsonb("npr_validation_result"), // NPR database validation
  sapsValidationResult: jsonb("saps_validation_result"), // SAPS database validation
  icaoPkdValidationResult: jsonb("icao_pkd_validation_result"), // ICAO PKD validation
  biometricValidationResult: jsonb("biometric_validation_result"), // Biometric validation
  
  // Fraud Detection Results
  fraudIndicators: jsonb("fraud_indicators"), // Detected fraud indicators
  behavioralAnalysis: jsonb("behavioral_analysis"), // Behavioral pattern analysis
  anomalyDetection: jsonb("anomaly_detection"), // Geographic/temporal anomalies
  
  // Response and Timing
  responseTime: integer("response_time"), // Response time in milliseconds
  errorCode: text("error_code"), // Error code if verification failed
  errorMessage: text("error_message"), // Error message if verification failed
  
  // Security and Privacy
  privacyLevel: text("privacy_level").default("standard"), // standard, enhanced, anonymous
  dataRetentionDays: integer("data_retention_days").default(2555), // 7 years default retention
  complianceFlags: jsonb("compliance_flags"), // POPIA compliance markers
  
  // Real-time Updates
  realTimeNotified: boolean("real_time_notified").default(false), // Whether real-time notification sent
  webhookDelivered: boolean("webhook_delivered").default(false), // Whether webhook was delivered
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// Batch Verification Requests - Support for bulk document verification
export const batchVerificationRequests = pgTable("batch_verification_requests", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  batchId: text("batch_id").notNull().unique(), // Unique batch identifier
  requesterId: varchar("requester_id").notNull().references(() => users.id), // Who requested the batch
  
  // Batch Information
  batchName: text("batch_name"), // Human-readable batch name
  description: text("description"), // Batch description
  totalDocuments: integer("total_documents").notNull(), // Total documents in batch
  processedDocuments: integer("processed_documents").notNull().default(0), // Processed count
  successfulVerifications: integer("successful_verifications").notNull().default(0), // Successful count
  failedVerifications: integer("failed_verifications").notNull().default(0), // Failed count
  
  // Processing Status
  status: text("status").notNull().default("pending"), // pending, processing, completed, failed
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  estimatedCompletion: timestamp("estimated_completion"),
  
  // Authorization and Security
  authorizationLevel: text("authorization_level").notNull(), // basic, elevated, administrative
  authorizedBy: varchar("authorized_by").references(() => users.id), // Who authorized the batch
  securityClassification: text("security_classification").default("official"), // Security level
  
  // Progress Tracking
  progressPercentage: integer("progress_percentage").notNull().default(0), // 0-100
  currentDocumentIndex: integer("current_document_index").default(0), // Current position
  lastProcessedAt: timestamp("last_processed_at"), // Last activity timestamp
  
  // Results and Reporting
  resultsSummary: jsonb("results_summary"), // Summary of verification results
  reportUrl: text("report_url"), // URL to detailed report
  errorSummary: jsonb("error_summary"), // Summary of errors encountered
  
  // Rate Limiting and Performance
  rateLimitPerSecond: integer("rate_limit_per_second").default(10), // Requests per second limit
  maxConcurrentVerifications: integer("max_concurrent_verifications").default(5),
  averageVerificationTime: integer("average_verification_time"), // Average time per verification
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Batch Verification Items - Individual items within a batch verification request
export const batchVerificationItems = pgTable("batch_verification_items", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  batchRequestId: varchar("batch_request_id").notNull().references(() => batchVerificationRequests.id),
  itemIndex: integer("item_index").notNull(), // Position in batch
  
  // Document Information
  verificationCode: text("verification_code").notNull(), // Document verification code to check
  documentNumber: text("document_number"), // Optional document number
  expectedDocumentType: text("expected_document_type"), // Expected document type
  
  // Processing Status
  status: text("status").notNull().default("pending"), // pending, processing, completed, failed
  processedAt: timestamp("processed_at"),
  processingTime: integer("processing_time"), // Time taken to process in milliseconds
  
  // Verification Results
  verificationResult: jsonb("verification_result"), // Complete verification response
  isValid: boolean("is_valid"), // Whether verification was successful
  confidenceScore: integer("confidence_score"), // Verification confidence (0-100)
  
  // Error Information
  errorCode: text("error_code"), // Error code if verification failed
  errorMessage: text("error_message"), // Human-readable error message
  retryCount: integer("retry_count").default(0), // Number of retry attempts
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// API Access Control - Manage third-party API access for verification
export const apiVerificationAccess = pgTable("api_verification_access", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  apiKeyId: varchar("api_key_id").notNull().references(() => apiKeys.id), // Associated API key
  organizationName: text("organization_name").notNull(), // Organization name
  contactEmail: text("contact_email").notNull(), // Primary contact
  
  // Access Configuration
  accessLevel: text("access_level").notNull().default("basic"), // basic, standard, premium, enterprise
  allowedDocumentTypes: text("allowed_document_types").array().notNull().default(sql`'{}'`), // Allowed document types
  allowedMethods: text("allowed_methods").array().notNull().default(sql`'{}'`), // qr_scan, manual_entry, document_lookup, batch
  
  // Rate Limiting
  dailyQuota: integer("daily_quota").notNull().default(1000), // Requests per day
  hourlyQuota: integer("hourly_quota").notNull().default(100), // Requests per hour
  burstLimit: integer("burst_limit").notNull().default(10), // Concurrent requests
  currentDailyUsage: integer("current_daily_usage").notNull().default(0),
  currentHourlyUsage: integer("current_hourly_usage").notNull().default(0),
  
  // IP and Geographic Restrictions
  allowedIpRanges: text("allowed_ip_ranges").array().default(sql`'{}'`), // CIDR ranges
  allowedCountries: text("allowed_countries").array().default(sql`'{}'`), // ISO country codes
  blockedIpRanges: text("blocked_ip_ranges").array().default(sql`'{}'`), // Blocked CIDR ranges
  
  // Webhook Configuration
  webhookUrl: text("webhook_url"), // Webhook endpoint for real-time updates
  webhookSecret: text("webhook_secret"), // Secret for webhook verification
  webhookEnabled: boolean("webhook_enabled").default(false),
  webhookEvents: text("webhook_events").array().default(sql`'{}'`), // Events to notify about
  
  // Monitoring and Analytics
  totalRequests: integer("total_requests").notNull().default(0), // Total lifetime requests
  successfulRequests: integer("successful_requests").notNull().default(0), // Successful requests
  failedRequests: integer("failed_requests").notNull().default(0), // Failed requests
  lastUsedAt: timestamp("last_used_at"), // Last API usage
  
  // Status and Lifecycle
  isActive: boolean("is_active").notNull().default(true), // Whether API access is active
  suspendedAt: timestamp("suspended_at"), // If suspended, when
  suspensionReason: text("suspension_reason"), // Reason for suspension
  expiresAt: timestamp("expires_at"), // API access expiry
  
  // Billing and Commercial
  billingTier: text("billing_tier").default("free"), // free, paid, enterprise
  costPerVerification: decimal("cost_per_verification", { precision: 10, scale: 4 }), // Cost per verification
  monthlyBill: decimal("monthly_bill", { precision: 10, scale: 2 }), // Current monthly bill
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Real-time Verification Sessions - Track ongoing verification sessions with real-time updates
export const realtimeVerificationSessions = pgTable("realtime_verification_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  sessionId: text("session_id").notNull().unique(), // Unique session identifier
  socketId: text("socket_id"), // WebSocket connection ID
  userId: varchar("user_id").references(() => users.id), // Optional authenticated user
  
  // Session Configuration
  sessionType: text("session_type").notNull().default("public"), // public, authenticated, api, batch
  verificationMethods: text("verification_methods").array().notNull().default(sql`'{}'`), // Enabled methods
  maxVerifications: integer("max_verifications").default(10), // Session verification limit
  currentVerifications: integer("current_verifications").default(0),
  
  // Real-time Status
  status: text("status").notNull().default("active"), // active, paused, completed, expired
  lastActivity: timestamp("last_activity").notNull().default(sql`now()`),
  expiresAt: timestamp("expires_at").notNull().default(sql`now() + interval '1 hour'`), // 1-hour session timeout
  
  // Geographic and Device Info
  ipAddress: text("ip_address"),
  country: text("country"), // Detected country
  region: text("region"), // Detected region/state
  city: text("city"), // Detected city
  userAgent: text("user_agent"),
  deviceInfo: jsonb("device_info"), // Device characteristics
  
  // Security and Fraud Prevention
  riskScore: integer("risk_score").default(0), // Session risk score (0-100)
  fraudFlags: jsonb("fraud_flags"), // Detected fraud indicators
  rateLimited: boolean("rate_limited").default(false), // Whether session is rate limited
  blockedAt: timestamp("blocked_at"), // If blocked, when
  
  // Session Metadata
  metadata: jsonb("metadata"), // Additional session data
  subscribedEvents: text("subscribed_events").array().default(sql`'{}'`), // WebSocket event subscriptions
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// Government Database Cross-validation Results - Store results from external database validations
export const govDatabaseValidations = pgTable("gov_database_validations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  verificationRecordId: varchar("verification_record_id").notNull().references(() => documentVerificationRecords.id),
  validationType: text("validation_type").notNull(), // npr, saps, icao_pkd, abis, mrz
  
  // Request Information
  requestId: text("request_id"), // External system request ID
  requestTimestamp: timestamp("request_timestamp").notNull().default(sql`now()`),
  responseTimestamp: timestamp("response_timestamp"),
  
  // Validation Results
  validationStatus: text("validation_status").notNull(), // pending, success, failed, timeout, error
  isValid: boolean("is_valid"), // Whether validation passed
  confidenceScore: integer("confidence_score"), // Confidence level (0-100)
  matchScore: integer("match_score"), // Data match score (0-100)
  
  // Detailed Results
  validationData: jsonb("validation_data").notNull(), // Complete validation response
  matchedFields: text("matched_fields").array().default(sql`'{}'`), // Successfully matched fields
  mismatchedFields: text("mismatched_fields").array().default(sql`'{}'`), // Fields that didn't match
  missingFields: text("missing_fields").array().default(sql`'{}'`), // Fields not provided by external system
  
  // Performance Metrics
  responseTime: integer("response_time"), // Response time in milliseconds
  retryCount: integer("retry_count").default(0), // Number of retries attempted
  
  // Error Information
  errorCode: text("error_code"), // Error code from external system
  errorMessage: text("error_message"), // Error message
  systemStatus: text("system_status"), // External system status at time of request
  
  // Quality Assessment
  dataQuality: integer("data_quality"), // Quality score of returned data (0-100)
  completeness: integer("completeness"), // Completeness score (0-100)
  reliability: integer("reliability"), // Reliability assessment (0-100)
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// ===================== ENHANCED SECURITY MONITORING SCHEMA =====================

// Audit Trail System - Comprehensive logging of all user actions
export const auditLogs = pgTable("audit_logs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id), // null for system actions
  sessionId: text("session_id"), // Session identifier
  action: text("action").notNull(), // Standardized action type
  entityType: text("entity_type"), // What was acted upon
  entityId: varchar("entity_id"), // ID of entity
  previousState: jsonb("previous_state"), // State before action
  newState: jsonb("new_state"), // State after action
  actionDetails: jsonb("action_details").notNull(), // Detailed action information
  outcome: text("outcome").notNull(), // success, failure, partial
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  location: text("location"),
  riskScore: integer("risk_score"), // Action risk assessment 0-100
  complianceFlags: jsonb("compliance_flags"), // POPIA compliance markers
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Security Incidents - Automated incident management
export const securityIncidents = pgTable("security_incidents", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  incidentType: text("incident_type").notNull(), // fraud, breach, suspicious_activity, policy_violation
  severity: text("severity").notNull(), // low, medium, high, critical
  status: text("status").notNull().default("open"), // open, investigating, resolved, closed
  title: text("title").notNull(),
  description: text("description").notNull(),
  triggeredBy: text("triggered_by").notNull(), // system, user, admin, automated_rule
  affectedUsers: jsonb("affected_users"), // Array of affected user IDs
  evidenceIds: jsonb("evidence_ids"), // Array of evidence document IDs
  correlatedEvents: jsonb("correlated_events"), // Array of related security event IDs
  investigationNotes: jsonb("investigation_notes"), // Array of investigation updates
  assignedTo: varchar("assigned_to").references(() => users.id), // Assigned investigator
  riskAssessment: jsonb("risk_assessment"), // Risk analysis details
  containmentActions: jsonb("containment_actions"), // Actions taken to contain
  resolution: text("resolution"), // How incident was resolved
  lessonsLearned: text("lessons_learned"), // Post-incident analysis
  openedAt: timestamp("opened_at").notNull().default(sql`now()`),
  resolvedAt: timestamp("resolved_at"),
  closedAt: timestamp("closed_at"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// User Behavior Analytics - Track user patterns for fraud detection
export const userBehaviorProfiles = pgTable("user_behavior_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id).unique(),
  typicalLocations: jsonb("typical_locations"), // Array of common locations
  typicalDevices: jsonb("typical_devices"), // Array of device fingerprints
  typicalTimes: jsonb("typical_times"), // Common activity times
  loginPatterns: jsonb("login_patterns"), // Login behavior analysis
  documentPatterns: jsonb("document_patterns"), // Document interaction patterns
  riskFactors: jsonb("risk_factors"), // Identified risk factors
  baselineScore: integer("baseline_score").notNull().default(0), // Normal behavior score
  lastAnalyzed: timestamp("last_analyzed").notNull().default(sql`now()`),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// Security Rules Engine - Dynamic security rule management
export const securityRules = pgTable("security_rules", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull().unique(),
  description: text("description").notNull(),
  category: text("category").notNull(), // fraud, access, document, authentication
  ruleType: text("rule_type").notNull(), // threshold, pattern, correlation, ml_model
  conditions: jsonb("conditions").notNull(), // Rule conditions in structured format
  actions: jsonb("actions").notNull(), // Actions to take when rule triggered
  severity: text("severity").notNull(), // low, medium, high, critical
  isActive: boolean("is_active").notNull().default(true),
  triggeredCount: integer("triggered_count").notNull().default(0),
  lastTriggered: timestamp("last_triggered"),
  falsePositiveCount: integer("false_positive_count").notNull().default(0),
  effectivenessScore: integer("effectiveness_score"), // 0-100 rule effectiveness
  createdBy: varchar("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

// Compliance Tracking - POPIA and regulatory compliance monitoring
export const complianceEvents = pgTable("compliance_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  eventType: text("event_type").notNull(), // data_access, data_modification, consent_given, consent_withdrawn, data_export, data_deletion
  regulation: text("regulation").notNull(), // POPIA, GDPR, etc.
  userId: varchar("user_id").references(() => users.id),
  dataSubjectId: varchar("data_subject_id").references(() => users.id), // The person whose data is being processed
  dataCategory: text("data_category").notNull(), // personal, biometric, document, health
  processingPurpose: text("processing_purpose").notNull(),
  legalBasis: text("legal_basis").notNull(),
  consentId: varchar("consent_id"), // Reference to consent record
  dataRetentionPeriod: integer("data_retention_period"), // In days
  processingDetails: jsonb("processing_details"), // Detailed processing information
  complianceStatus: text("compliance_status").notNull(), // compliant, non_compliant, under_review
  reviewNotes: text("review_notes"),
  reviewedBy: varchar("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// Security Metrics - Real-time security KPIs
export const securityMetrics = pgTable("security_metrics", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  metricName: text("metric_name").notNull(),
  metricValue: integer("metric_value").notNull(),
  metricUnit: text("metric_unit").notNull(), // count, percentage, score, rate
  timeWindow: text("time_window").notNull(), // hour, day, week, month
  aggregationType: text("aggregation_type").notNull(), // sum, avg, max, min, count
  dimensions: jsonb("dimensions"), // Additional metric dimensions
  threshold: jsonb("threshold"), // Alert thresholds
  isAlert: boolean("is_alert").notNull().default(false),
  calculatedAt: timestamp("calculated_at").notNull().default(sql`now()`),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

// ===================== SECURITY MONITORING INSERT SCHEMAS =====================

export const insertAuditLogSchema = createInsertSchema(auditLogs).omit({
  id: true,
  createdAt: true,
});

export const insertSecurityIncidentSchema = createInsertSchema(securityIncidents).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  openedAt: true,
});

export const insertUserBehaviorProfileSchema = createInsertSchema(userBehaviorProfiles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  lastAnalyzed: true,
});

export const insertSecurityRuleSchema = createInsertSchema(securityRules).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  triggeredCount: true,
  falsePositiveCount: true,
});

export const insertComplianceEventSchema = createInsertSchema(complianceEvents).omit({
  id: true,
  createdAt: true,
});

export const insertSecurityMetricSchema = createInsertSchema(securityMetrics).omit({
  id: true,
  createdAt: true,
  calculatedAt: true,
});

// ===================== SECURITY MONITORING TYPES =====================

export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = z.infer<typeof insertAuditLogSchema>;

export type SecurityIncident = typeof securityIncidents.$inferSelect;
export type InsertSecurityIncident = z.infer<typeof insertSecurityIncidentSchema>;

export type UserBehaviorProfile = typeof userBehaviorProfiles.$inferSelect;
export type InsertUserBehaviorProfile = z.infer<typeof insertUserBehaviorProfileSchema>;

export type SecurityRule = typeof securityRules.$inferSelect;
export type InsertSecurityRule = z.infer<typeof insertSecurityRuleSchema>;

export type ComplianceEvent = typeof complianceEvents.$inferSelect;
export type InsertComplianceEvent = z.infer<typeof insertComplianceEventSchema>;

export type SecurityMetric = typeof securityMetrics.$inferSelect;
export type InsertSecurityMetric = z.infer<typeof insertSecurityMetricSchema>;

// ===================== SECURITY ACTION TYPES =====================

export const AuditAction = {
  // Authentication actions
  LOGIN_ATTEMPT: 'auth.login_attempt',
  LOGIN_SUCCESS: 'auth.login_success',
  LOGIN_FAILED: 'auth.login_failed',
  LOGOUT: 'auth.logout',
  PASSWORD_CHANGED: 'auth.password_changed',
  ACCOUNT_LOCKED: 'auth.account_locked',
  
  // Document actions
  DOCUMENT_VIEWED: 'document.viewed',
  DOCUMENT_DOWNLOADED: 'document.downloaded',
  DOCUMENT_UPLOADED: 'document.uploaded',
  DOCUMENT_DELETED: 'document.deleted',
  DOCUMENT_MODIFIED: 'document.modified',
  DOCUMENT_VERIFIED: 'document.verified',
  
  // User management actions
  USER_CREATED: 'user.created',
  USER_UPDATED: 'user.updated',
  USER_DELETED: 'user.deleted',
  USER_DEACTIVATED: 'user.deactivated',
  USER_ROLE_CHANGED: 'user.role_changed',
  
  // Admin actions
  ADMIN_LOGIN: 'admin.login',
  ADMIN_ACTION: 'admin.action',
  SYSTEM_CONFIG_CHANGED: 'admin.config_changed',
  
  // API actions
  API_CALL: 'api.call',
  API_KEY_USED: 'api.key_used',
  
  // Integration actions
  DHA_API_CALL: 'integration.dha_call',
  SAPS_API_CALL: 'integration.saps_call',
  ICAO_API_CALL: 'integration.icao_call',
} as const;

export const ComplianceEventType = {
  DATA_ACCESSED: 'data.accessed',
  DATA_MODIFIED: 'data.modified',
  DATA_EXPORTED: 'data.exported',
  DATA_DELETED: 'data.deleted',
  CONSENT_GIVEN: 'consent.given',
  CONSENT_WITHDRAWN: 'consent.withdrawn',
  DATA_BREACH_DETECTED: 'breach.detected',
  DATA_RETENTION_EXPIRED: 'retention.expired',
} as const;

// ===================== SECURITY MONITORING VALIDATION SCHEMAS =====================

// Security Metrics Query Schema
export const securityMetricsQuerySchema = z.object({
  type: z.string().optional(),
  hours: z.number().min(1).max(8760).optional(), // max 1 year
  timeframe: z.enum(['1h', '24h', '7d', '30d']).optional(),
  limit: z.number().min(1).max(1000).optional(),
  offset: z.number().min(0).optional()
});

// Error Logging Schema
export const errorLogCreationSchema = z.object({
  message: z.string().min(1).max(2000),
  stack: z.string().max(10000).optional(),
  componentStack: z.string().max(5000).optional(),
  timestamp: z.string().optional(),
  userAgent: z.string().max(500).optional(),
  url: z.string().max(500).optional()
});

// Security Events Query Schema  
export const securityEventsQuerySchema = z.object({
  limit: z.number().min(1).max(500).optional(),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  eventType: z.string().max(100).optional(),
  userId: z.string().uuid().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional()
});

// Error Logs Query Schema
export const errorLogsQuerySchema = z.object({
  limit: z.number().min(1).max(500).optional(),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  errorType: z.string().max(100).optional(),
  isResolved: z.boolean().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional()
});

// Alert Management Schemas
export const alertFilterSchema = z.object({
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  status: z.enum(['active', 'acknowledged', 'resolved', 'escalated']).optional(),
  userId: z.string().uuid().optional(),
  limit: z.number().min(1).max(500).optional(),
  offset: z.number().min(0).optional()
});

export const alertActionSchema = z.object({
  notes: z.string().max(1000).optional(),
  resolution: z.string().min(1).max(1000).optional(),
  reason: z.string().min(1).max(500).optional()
});

// Alert Rule Creation Schema
export const alertRuleCreationSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().min(1).max(1000),
  conditions: z.array(z.object({
    field: z.string().min(1).max(100),
    operator: z.enum(['gt', 'lt', 'eq', 'gte', 'lte', 'contains', 'pattern']),
    value: z.union([z.string(), z.number(), z.boolean()]),
    timeWindow: z.number().min(1).max(1440).optional() // max 24 hours
  })).min(1).max(10),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  channels: z.array(z.object({
    type: z.enum(['email', 'sms', 'webhook', 'dashboard', 'websocket']),
    target: z.string().min(1).max(500),
    enabled: z.boolean()
  })).min(1).max(10),
  enabled: z.boolean(),
  cooldown: z.number().min(1).max(1440), // max 24 hours
  tags: z.array(z.string().max(50)).max(20)
});

export const alertRuleUpdateSchema = alertRuleCreationSchema.partial();

// Incident Management Schemas
export const incidentFilterSchema = z.object({
  status: z.enum(['open', 'in_progress', 'resolved', 'closed']).optional(),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  assignedTo: z.string().uuid().optional(),
  limit: z.number().min(1).max(500).optional(),
  offset: z.number().min(0).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional()
});

export const incidentActionSchema = z.object({
  assignedTo: z.string().uuid().optional(),
  resolution: z.string().min(1).max(2000).optional(),
  notes: z.string().max(1000).optional(),
  priority: z.enum(['low', 'medium', 'high', 'critical']).optional()
});

// Audit Log Query Schema
export const auditLogQuerySchema = z.object({
  userId: z.string().uuid().optional(),
  action: z.string().max(100).optional(),
  entityType: z.string().max(100).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().min(1).max(1000).optional(),
  offset: z.number().min(0).optional(),
  outcome: z.enum(['success', 'failure']).optional()
});

// Compliance Report Query Schema
export const complianceReportQuerySchema = z.object({
  regulation: z.enum(['POPIA', 'GDPR']),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  eventType: z.string().max(100).optional(),
  complianceStatus: z.enum(['compliant', 'non_compliant', 'under_review']).optional()
});

// Security Rules Query Schema
export const securityRulesQuerySchema = z.object({
  category: z.string().max(100).optional(),
  isActive: z.boolean().optional(),
  ruleType: z.string().max(100).optional(),
  limit: z.number().min(1).max(500).optional(),
  offset: z.number().min(0).optional()
});

export const securityRuleToggleSchema = z.object({
  enabled: z.boolean()
});

// Dashboard Query Schema
export const dashboardQuerySchema = z.object({
  timeframe: z.enum(['1h', '24h', '7d', '30d']).optional(),
  includeAlerts: z.boolean().optional(),
  includeTrends: z.boolean().optional(),
  includeMetrics: z.boolean().optional()
});

// Fraud Statistics Query Schema
export const fraudStatisticsQuerySchema = z.object({
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  userId: z.string().uuid().optional(),
  riskThreshold: z.number().min(0).max(100).optional()
});

// User Behavior Analysis Query Schema
export const userBehaviorQuerySchema = z.object({
  userId: z.string().uuid(),
  includeProfile: z.boolean().optional(),
  includeAnalysis: z.boolean().optional(),
  includeDevicePatterns: z.boolean().optional(),
  timeframe: z.enum(['24h', '7d', '30d']).optional()
});

// Alert Statistics Query Schema
export const alertStatisticsQuerySchema = z.object({
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  status: z.enum(['active', 'acknowledged', 'resolved', 'escalated']).optional()
});

// Compliance Events Query Schema
export const complianceEventsQuerySchema = z.object({
  regulation: z.string().max(50).optional(),
  eventType: z.string().max(100).optional(),
  complianceStatus: z.enum(['compliant', 'non_compliant', 'under_review']).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().min(1).max(500).optional(),
  offset: z.number().min(0).optional()
});

// System Health Query Schema
export const systemHealthQuerySchema = z.object({
  includeMetrics: z.boolean().optional(),
  includeIntegrations: z.boolean().optional(),
  includePerformance: z.boolean().optional()
});

// Document Template Query Schema
export const documentTemplateQuerySchema = z.object({
  type: z.enum(['birth_certificate', 'passport', 'id_card', 'permit', 'certificate', 'visa']).optional()
});

// Document Verification Query Schema  
export const documentVerificationQuerySchema = z.object({
  documentType: z.enum(['birth_certificate', 'passport', 'id_card', 'permit', 'certificate', 'visa']).optional(),
  documentId: z.string().uuid().optional()
});

// Compliance Report Parameter Schema (for URL params)
export const complianceReportParamsSchema = z.object({
  regulation: z.enum(['POPIA', 'GDPR']),
  startDate: z.string().datetime(),
  endDate: z.string().datetime()
});

// Input sanitization helper schemas
export const sanitizedStringSchema = z.string().transform((val) => {
  // Basic XSS prevention - remove HTML tags and escape special chars
  return val.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
            .replace(/[<>]/g, (match) => match === '<' ? '&lt;' : '&gt;')
            .trim();
});

export const sanitizedOptionalStringSchema = sanitizedStringSchema.optional();

// Live Document Verification Records Table
export const liveDocumentVerificationRecords = pgTable("live_document_verification_records", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  verificationCode: text("verification_code").notNull().unique(),
  documentHash: text("document_hash").notNull(),
  documentType: text("document_type").notNull(),
  documentNumber: text("document_number").notNull(),
  documentData: jsonb("document_data").notNull(),
  userId: varchar("user_id").references(() => users.id),
  verificationUrl: text("verification_url").notNull(),
  hashtags: text().array().notNull(),
  isActive: boolean("is_active").notNull().default(true),
  verificationCount: integer("verification_count").notNull().default(0),
  lastVerifiedAt: timestamp("last_verified_at"),
  issuedAt: timestamp("issued_at").notNull().default(sql`now()`),
  expiryDate: timestamp("expiry_date"),
  issuingOffice: text("issuing_office"),
  issuingOfficer: text("issuing_officer"),
  securityFeatures: jsonb("security_features"),
  revokedAt: timestamp("revoked_at"),
  revocationReason: text("revocation_reason"),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});


// WebSocket Event Schemas
export const webSocketSubscriptionSchema = z.object({
  eventTypes: z.array(z.enum(['security_alert', 'fraud_alert', 'incident_update', 'system_status'])).min(1),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  userId: z.string().uuid().optional() // for user-specific alerts
});

// ===================== VALIDATION SCHEMA EXPORTS =====================

export type SecurityMetricsQuery = z.infer<typeof securityMetricsQuerySchema>;
export type ErrorLogCreation = z.infer<typeof errorLogCreationSchema>;
export type SecurityEventsQuery = z.infer<typeof securityEventsQuerySchema>;
export type ErrorLogsQuery = z.infer<typeof errorLogsQuerySchema>;
export type AlertFilter = z.infer<typeof alertFilterSchema>;
export type AlertAction = z.infer<typeof alertActionSchema>;
export type AlertRuleCreation = z.infer<typeof alertRuleCreationSchema>;
export type AlertRuleUpdate = z.infer<typeof alertRuleUpdateSchema>;
export type IncidentFilter = z.infer<typeof incidentFilterSchema>;
export type IncidentAction = z.infer<typeof incidentActionSchema>;
export type AuditLogQuery = z.infer<typeof auditLogQuerySchema>;
export type ComplianceReportQuery = z.infer<typeof complianceReportQuerySchema>;
export type SecurityRulesQuery = z.infer<typeof securityRulesQuerySchema>;
export type SecurityRuleToggle = z.infer<typeof securityRuleToggleSchema>;
export type DashboardQuery = z.infer<typeof dashboardQuerySchema>;
export type FraudStatisticsQuery = z.infer<typeof fraudStatisticsQuerySchema>;
export type UserBehaviorQuery = z.infer<typeof userBehaviorQuerySchema>;
export type AlertStatisticsQuery = z.infer<typeof alertStatisticsQuerySchema>;
export type ComplianceEventsQuery = z.infer<typeof complianceEventsQuerySchema>;
export type SystemHealthQuery = z.infer<typeof systemHealthQuerySchema>;
export type DocumentTemplateQuery = z.infer<typeof documentTemplateQuerySchema>;
export type DocumentVerificationQuery = z.infer<typeof documentVerificationQuerySchema>;
export type ComplianceReportParams = z.infer<typeof complianceReportParamsSchema>;
export type WebSocketSubscription = z.infer<typeof webSocketSubscriptionSchema>;

// ===================== COMPREHENSIVE DHA DIGITAL SERVICES INSERT SCHEMAS =====================

// New Document Types Insert Schemas
export const insertSouthAfricanIdSchema = createInsertSchema(southAfricanIds).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertStudyPermitSchema = createInsertSchema(studyPermits).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertBusinessPermitSchema = createInsertSchema(businessPermits).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertVisitorsVisaSchema = createInsertSchema(visitorsVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTransitVisaSchema = createInsertSchema(transitVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertMedicalTreatmentVisaSchema = createInsertSchema(medicalTreatmentVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertExchangePermitSchema = createInsertSchema(exchangePermits).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertRelativesVisaSchema = createInsertSchema(relativesVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCriticalSkillsVisaSchema = createInsertSchema(criticalSkillsVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertIntraCompanyTransferVisaSchema = createInsertSchema(intraCompanyTransferVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCorporateVisaSchema = createInsertSchema(corporateVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTreatyVisaSchema = createInsertSchema(treatyVisas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTemporaryResidencePermitSchema = createInsertSchema(temporaryResidencePermits).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Workflow and Security Systems Insert Schemas

// CRITICAL SECURITY TABLES
export const insertEncryptedArtifactSchema = createInsertSchema(encryptedArtifacts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// NORMALIZED WORKFLOW TABLES (8-STAGE DHA PROCESS)
export const insertWorkflowStageSchema = createInsertSchema(workflowStages).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertWorkflowTransitionSchema = createInsertSchema(workflowTransitions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertDocumentWorkflowInstanceSchema = createInsertSchema(documentWorkflowInstances).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertWorkflowStageExecutionSchema = createInsertSchema(workflowStageExecutions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// EXISTING WORKFLOW SCHEMAS (LEGACY - TO BE DEPRECATED)
export const insertDocumentProcessingWorkflowSchema = createInsertSchema(documentProcessingWorkflow).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertWorkflowStageTransitionSchema = createInsertSchema(workflowStageTransitions).omit({
  id: true,
  createdAt: true,
});

export const insertDocumentClassificationSchema = createInsertSchema(documentClassifications).omit({
  id: true,
  createdAt: true,
});

export const insertFraudDetectionAnalysisSchema = createInsertSchema(fraudDetectionAnalysis).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// ===================== COMPREHENSIVE DHA TYPES =====================

// CRITICAL SECURITY AND WORKFLOW TYPES
export type EncryptedArtifact = typeof encryptedArtifacts.$inferSelect;
export type InsertEncryptedArtifact = z.infer<typeof insertEncryptedArtifactSchema>;

// NORMALIZED 8-STAGE DHA WORKFLOW TYPES
export type WorkflowStage = typeof workflowStages.$inferSelect;
export type InsertWorkflowStage = z.infer<typeof insertWorkflowStageSchema>;

export type WorkflowTransition = typeof workflowTransitions.$inferSelect;
export type InsertWorkflowTransition = z.infer<typeof insertWorkflowTransitionSchema>;

export type DocumentWorkflowInstance = typeof documentWorkflowInstances.$inferSelect;
export type InsertDocumentWorkflowInstance = z.infer<typeof insertDocumentWorkflowInstanceSchema>;

export type WorkflowStageExecution = typeof workflowStageExecutions.$inferSelect;
export type InsertWorkflowStageExecution = z.infer<typeof insertWorkflowStageExecutionSchema>;

// New Document Types
export type SouthAfricanId = typeof southAfricanIds.$inferSelect;
export type InsertSouthAfricanId = z.infer<typeof insertSouthAfricanIdSchema>;

export type StudyPermit = typeof studyPermits.$inferSelect;
export type InsertStudyPermit = z.infer<typeof insertStudyPermitSchema>;

export type BusinessPermit = typeof businessPermits.$inferSelect;
export type InsertBusinessPermit = z.infer<typeof insertBusinessPermitSchema>;

export type VisitorsVisa = typeof visitorsVisas.$inferSelect;
export type InsertVisitorsVisa = z.infer<typeof insertVisitorsVisaSchema>;

export type TransitVisa = typeof transitVisas.$inferSelect;
export type InsertTransitVisa = z.infer<typeof insertTransitVisaSchema>;

export type MedicalTreatmentVisa = typeof medicalTreatmentVisas.$inferSelect;
export type InsertMedicalTreatmentVisa = z.infer<typeof insertMedicalTreatmentVisaSchema>;

export type ExchangePermit = typeof exchangePermits.$inferSelect;
export type InsertExchangePermit = z.infer<typeof insertExchangePermitSchema>;

export type RelativesVisa = typeof relativesVisas.$inferSelect;
export type InsertRelativesVisa = z.infer<typeof insertRelativesVisaSchema>;

export type CriticalSkillsVisa = typeof criticalSkillsVisas.$inferSelect;
export type InsertCriticalSkillsVisa = z.infer<typeof insertCriticalSkillsVisaSchema>;

export type IntraCompanyTransferVisa = typeof intraCompanyTransferVisas.$inferSelect;
export type InsertIntraCompanyTransferVisa = z.infer<typeof insertIntraCompanyTransferVisaSchema>;

export type CorporateVisa = typeof corporateVisas.$inferSelect;
export type InsertCorporateVisa = z.infer<typeof insertCorporateVisaSchema>;

export type TreatyVisa = typeof treatyVisas.$inferSelect;
export type InsertTreatyVisa = z.infer<typeof insertTreatyVisaSchema>;

export type TemporaryResidencePermit = typeof temporaryResidencePermits.$inferSelect;
export type InsertTemporaryResidencePermit = z.infer<typeof insertTemporaryResidencePermitSchema>;

// Workflow and Security System Types
export type DocumentProcessingWorkflow = typeof documentProcessingWorkflow.$inferSelect;
export type InsertDocumentProcessingWorkflow = z.infer<typeof insertDocumentProcessingWorkflowSchema>;

export type WorkflowStageTransition = typeof workflowStageTransitions.$inferSelect;
export type InsertWorkflowStageTransition = z.infer<typeof insertWorkflowStageTransitionSchema>;

export type DocumentClassification = typeof documentClassifications.$inferSelect;
export type InsertDocumentClassification = z.infer<typeof insertDocumentClassificationSchema>;

export type FraudDetectionAnalysis = typeof fraudDetectionAnalysis.$inferSelect;
export type InsertFraudDetectionAnalysis = z.infer<typeof insertFraudDetectionAnalysisSchema>;

// ===================== COMPREHENSIVE VERIFICATION SYSTEM INSERT SCHEMAS =====================

// Document Verification Records insert schema
export const insertDocumentVerificationRecordSchema = createInsertSchema(documentVerificationRecords).omit({
  id: true,
  verificationCount: true,
  lastVerifiedAt: true,
  aiAuthenticityScore: true,
  aiVerificationMetadata: true,
  revokedAt: true,
  revocationReason: true,
  createdAt: true,
  updatedAt: true,
});

// Document Verification History insert schema
export const insertDocumentVerificationHistorySchema = createInsertSchema(documentVerificationHistory).omit({
  id: true,
  createdAt: true,
});

// Batch Verification Requests insert schema
export const insertBatchVerificationRequestSchema = createInsertSchema(batchVerificationRequests).omit({
  id: true,
  processedDocuments: true,
  successfulVerifications: true,
  failedVerifications: true,
  startedAt: true,
  completedAt: true,
  progressPercentage: true,
  currentDocumentIndex: true,
  lastProcessedAt: true,
  averageVerificationTime: true,
  createdAt: true,
  updatedAt: true,
});

// Batch Verification Items insert schema
export const insertBatchVerificationItemSchema = createInsertSchema(batchVerificationItems).omit({
  id: true,
  processedAt: true,
  processingTime: true,
  retryCount: true,
  createdAt: true,
});

// API Verification Access insert schema
export const insertApiVerificationAccessSchema = createInsertSchema(apiVerificationAccess).omit({
  id: true,
  currentDailyUsage: true,
  currentHourlyUsage: true,
  totalRequests: true,
  successfulRequests: true,
  failedRequests: true,
  lastUsedAt: true,
  suspendedAt: true,
  monthlyBill: true,
  createdAt: true,
  updatedAt: true,
});

// Real-time Verification Sessions insert schema
export const insertRealtimeVerificationSessionSchema = createInsertSchema(realtimeVerificationSessions).omit({
  id: true,
  currentVerifications: true,
  lastActivity: true,
  riskScore: true,
  rateLimited: true,
  blockedAt: true,
  createdAt: true,
});

// Government Database Validations insert schema
export const insertGovDatabaseValidationSchema = createInsertSchema(govDatabaseValidations).omit({
  id: true,
  responseTimestamp: true,
  responseTime: true,
  retryCount: true,
  createdAt: true,
});

// ===================== COMPREHENSIVE VERIFICATION SYSTEM TYPES =====================

export type DocumentVerificationRecord = typeof documentVerificationRecords.$inferSelect;
export type InsertDocumentVerificationRecord = z.infer<typeof insertDocumentVerificationRecordSchema>;

export type DocumentVerificationHistory = typeof documentVerificationHistory.$inferSelect;
export type InsertDocumentVerificationHistory = z.infer<typeof insertDocumentVerificationHistorySchema>;

export type BatchVerificationRequest = typeof batchVerificationRequests.$inferSelect;
export type InsertBatchVerificationRequest = z.infer<typeof insertBatchVerificationRequestSchema>;

export type BatchVerificationItem = typeof batchVerificationItems.$inferSelect;
export type InsertBatchVerificationItem = z.infer<typeof insertBatchVerificationItemSchema>;

export type ApiVerificationAccess = typeof apiVerificationAccess.$inferSelect;
export type InsertApiVerificationAccess = z.infer<typeof insertApiVerificationAccessSchema>;

export type RealtimeVerificationSession = typeof realtimeVerificationSessions.$inferSelect;
export type InsertRealtimeVerificationSession = z.infer<typeof insertRealtimeVerificationSessionSchema>;

export type GovDatabaseValidation = typeof govDatabaseValidations.$inferSelect;
export type InsertGovDatabaseValidation = z.infer<typeof insertGovDatabaseValidationSchema>;

// ===================== VERIFICATION API VALIDATION SCHEMAS =====================

// Document verification schema for manual entry
export const documentVerificationSchema = z.object({
  verificationCode: z.string().length(12, "Verification code must be exactly 12 characters"),
  verificationMethod: z.enum(["qr_scan", "manual_entry", "document_lookup", "batch", "api"]).default("manual_entry"),
  requesterInfo: z.record(z.any()).optional(),
  deviceInfo: z.record(z.any()).optional(),
  location: z.record(z.any()).optional(),
});

// Document lookup schema for searching by document number
export const documentLookupSchema = z.object({
  documentNumber: z.string().min(1, "Document number is required"),
  documentType: z.enum([
    'birth_certificate', 'death_certificate', 'marriage_certificate', 'divorce_certificate',
    'passport', 'sa_id', 'smart_id', 'temporary_id',
    'study_permit', 'work_permit', 'business_permit', 'visitor_visa', 'transit_visa',
    'permanent_residence', 'temporary_residence', 'refugee_permit', 'asylum_permit',
    'diplomatic_passport', 'exchange_permit', 'relatives_visa', 'emergency_travel_document'
  ]),
  includeHistory: z.boolean().default(false),
  verificationMethod: z.literal("document_lookup"),
});

// Batch verification request schema
export const batchVerificationCreationSchema = z.object({
  batchName: z.string().min(1, "Batch name is required"),
  description: z.string().optional(),
  documents: z.array(z.object({
    verificationCode: z.string().length(12),
    documentNumber: z.string().optional(),
    expectedDocumentType: z.string().optional(),
  })).min(1, "At least one document is required").max(1000, "Maximum 1000 documents per batch"),
  authorizationLevel: z.enum(["basic", "elevated", "administrative"]).default("basic"),
  rateLimitPerSecond: z.number().min(1).max(100).default(10),
  maxConcurrentVerifications: z.number().min(1).max(20).default(5),
});

// API verification request schema
export const apiVerificationRequestSchema = z.object({
  verificationCode: z.string().length(12),
  includeHistory: z.boolean().default(false),
  includeSecurityFeatures: z.boolean().default(true),
  crossValidate: z.boolean().default(false), // Whether to perform government database cross-validation
  anonymize: z.boolean().default(false), // Whether to anonymize response data
  webhookUrl: z.string().url().optional(), // Optional webhook for async response
});

// Public verification schema (most restrictive)
export const publicVerificationSchema = z.object({
  verificationCode: z.string().length(12, "Please enter a valid 12-character verification code"),
});

// QR code verification schema  
export const qrVerificationSchema = z.object({
  qrData: z.string().min(1, "QR code data is required"),
  verificationMethod: z.literal("qr_scan"),
  scannerInfo: z.object({
    scannerType: z.enum(["mobile_camera", "desktop_camera", "file_upload"]),
    quality: z.number().min(0).max(100).optional(),
    scanTime: z.number().optional(), // Milliseconds to scan
  }).optional(),
});

// Verification result schema for API responses
export const verificationResultSchema = z.object({
  isValid: z.boolean(),
  verificationId: z.string().uuid(),
  documentType: z.string().optional(),
  documentNumber: z.string().optional(),
  issuedDate: z.string().optional(),
  expiryDate: z.string().optional(),
  holderName: z.string().optional(),
  verificationCount: z.number(),
  lastVerified: z.string().datetime().optional(),
  issueOffice: z.string().optional(),
  issuingOfficer: z.string().optional(),
  hashtags: z.array(z.string()).optional(),
  securityFeatures: z.object({
    brailleEncoded: z.boolean(),
    holographicSeal: z.boolean(),
    qrCodeValid: z.boolean(),
    hashValid: z.boolean(),
    biometricData: z.boolean(),
    digitalSignature: z.boolean(),
  }).optional(),
  confidenceLevel: z.number().min(0).max(100).optional(),
  verificationScore: z.number().min(0).max(100).optional(),
  fraudRiskLevel: z.enum(["low", "medium", "high", "critical"]).optional(),
  anomalies: z.array(z.string()).optional(),
  message: z.string().optional(),
  responseTime: z.number().optional(), // Response time in milliseconds
  verificationHistory: z.array(z.object({
    timestamp: z.string().datetime(),
    ipAddress: z.string().optional(),
    location: z.union([z.string(), z.object({
      country: z.string().optional(),
      region: z.string().optional(),
      city: z.string().optional(),
      coordinates: z.object({
        lat: z.number(),
        lng: z.number()
      }).optional()
    })]).optional(),
    verificationMethod: z.string(),
  })).optional(),
});

// ===================== GOVERNMENT AUTHENTICATION AND COMPLIANCE SCHEMAS =====================

// Government Officer Authentication
export const governmentOfficerSchema = z.object({
  officerBadgeNumber: z.string().min(1),
  officerRank: z.enum(["junior_officer", "senior_officer", "supervisor", "manager", "director", "deputy_director_general", "director_general"]),
  departmentCode: z.string().min(1).max(10),
  clearanceLevel: z.enum(["official", "confidential", "secret", "top_secret"]),
  biometricVerified: z.boolean().default(false)
});

// Classification Level Assignment
export const classificationAssignmentSchema = z.object({
  documentId: z.string().uuid(),
  classificationLevel: z.enum(["unclassified", "official", "confidential", "secret", "top_secret"]),
  classificationReason: z.string().min(1),
  justification: z.string().min(10),
  declassificationDate: z.string().datetime().optional(),
  accessControlList: z.array(z.string()).optional()
});

// Comprehensive Document Processing Request
export const documentProcessingRequestSchema = z.object({
  applicantId: z.string().uuid(),
  documentType: z.enum([
    "birth_certificate", "south_african_id", "passport", "work_permit", 
    "marriage_certificate", "death_certificate", "refugee_id", "temporary_residence_permit",
    "permanent_residence_permit", "study_permit", "business_permit", "visitors_visa",
    "transit_visa", "medical_treatment_visa", "exchange_permit", "relatives_visa",
    "critical_skills_visa", "intra_company_transfer_visa", "corporate_visa", "treaty_visa",
    "asylum_refugee_documents"
  ]),
  applicationData: z.record(z.any()),
  supportingDocuments: z.array(z.object({
    documentType: z.string(),
    documentUrl: z.string().url(),
    verified: z.boolean().default(false)
  })),
  priorityLevel: z.enum(["low", "normal", "high", "urgent"]).default("normal"),
  expeditedProcessing: z.boolean().default(false)
});

// Fraud Alert Creation Schema
export const fraudAlertCreationSchema = z.object({
  documentId: z.string().uuid(),
  alertType: z.enum(["identity_fraud", "document_forgery", "application_fraud", "behavioral_anomaly", "duplicate_application"]),
  riskLevel: z.enum(["low", "medium", "high", "critical"]),
  alertDescription: z.string().min(1),
  evidenceUrls: z.array(z.string().url()).optional(),
  automaticActions: z.array(z.enum(["flag_application", "require_manual_review", "block_processing", "escalate_to_supervisor"])),
  requiresInvestigation: z.boolean().default(false)
});

// Security Audit Request Schema
export const securityAuditRequestSchema = z.object({
  auditType: z.enum(["compliance_check", "security_review", "fraud_investigation", "data_integrity_check"]),
  targetEntityType: z.enum(["document", "application", "user", "system"]),
  targetEntityId: z.string().uuid(),
  auditScope: z.array(z.string()),
  requestedBy: z.string().uuid(),
  urgencyLevel: z.enum(["routine", "priority", "urgent", "critical"]).default("routine"),
  complianceFramework: z.array(z.enum(["POPIA", "PFMA", "GDPR", "ISO27001", "government_security_framework"])),
  expectedCompletionDate: z.string().datetime().optional()
});

// ===================== FINAL GOVERNMENT COMPLIANCE TYPES =====================

export type GovernmentOfficer = z.infer<typeof governmentOfficerSchema>;
export type ClassificationAssignment = z.infer<typeof classificationAssignmentSchema>;
export type DocumentProcessingRequest = z.infer<typeof documentProcessingRequestSchema>;
export type FraudAlertCreation = z.infer<typeof fraudAlertCreationSchema>;
export type SecurityAuditRequest = z.infer<typeof securityAuditRequestSchema>;

// ===================== PRODUCTION-READY VALIDATION HELPERS =====================

// South African ID Number Validation
export const saIdNumberSchema = z.string().regex(
  /^\d{13}$/,
  "South African ID number must be 13 digits"
).refine((id) => {
  // Basic Luhn algorithm validation for SA ID numbers
  const digits = id.split('').map(Number);
  let sum = 0;
  for (let i = 0; i < 12; i++) {
    if (i % 2 === 0) {
      sum += digits[i];
    } else {
      sum += Math.floor(digits[i] * 2 / 10) + (digits[i] * 2 % 10);
    }
  }
  const checkDigit = (10 - (sum % 10)) % 10;
  return checkDigit === digits[12];
}, "Invalid South African ID number checksum");

// AI Assistant System Insert Schemas
export const insertAiDocumentSessionSchema = createInsertSchema(aiDocumentSessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertDocumentAutoFillTemplateSchema = createInsertSchema(documentAutoFillTemplates).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertOcrFieldDefinitionSchema = createInsertSchema(ocrFieldDefinitions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertAiKnowledgeBaseSchema = createInsertSchema(aiKnowledgeBase).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertAiConversationAnalyticsSchema = createInsertSchema(aiConversationAnalytics).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// AI Assistant System Types
export type AiDocumentSession = typeof aiDocumentSessions.$inferSelect;
export type InsertAiDocumentSession = z.infer<typeof insertAiDocumentSessionSchema>;

export type DocumentAutoFillTemplate = typeof documentAutoFillTemplates.$inferSelect;
export type InsertDocumentAutoFillTemplate = z.infer<typeof insertDocumentAutoFillTemplateSchema>;

export type OcrFieldDefinition = typeof ocrFieldDefinitions.$inferSelect;
export type InsertOcrFieldDefinition = z.infer<typeof insertOcrFieldDefinitionSchema>;

export type AiKnowledgeBase = typeof aiKnowledgeBase.$inferSelect;
export type InsertAiKnowledgeBase = z.infer<typeof insertAiKnowledgeBaseSchema>;

export type AiConversationAnalytics = typeof aiConversationAnalytics.$inferSelect;
export type InsertAiConversationAnalytics = z.infer<typeof insertAiConversationAnalyticsSchema>;

// AI Chat Assistant API Schemas
export const aiChatRequestSchema = z.object({
  message: z.string().min(1).max(10000),
  conversationId: z.string().uuid(),
  language: z.enum(['en', 'zu', 'xh', 'af', 'st', 'tn', 'ts', 'ss', 've', 'nr', 'nso']).default('en'),
  includeContext: z.boolean().default(true),
  documentContext: z.object({
    sessionId: z.string().uuid(),
    documentType: z.string(),
    extractedFields: z.record(z.any())
  }).optional()
});

export const aiTranslationRequestSchema = z.object({
  text: z.string().min(1).max(10000),
  targetLanguage: z.enum(['en', 'zu', 'xh', 'af', 'st', 'tn', 'ts', 'ss', 've', 'nr', 'nso']),
  sourceLanguage: z.string().default('auto')
});

export const aiDocumentAnalysisRequestSchema = z.object({
  documentContent: z.string().min(1),
  documentType: z.enum([
    'birth_certificate', 'death_certificate', 'marriage_certificate', 'divorce_certificate',
    'passport', 'sa_id', 'smart_id', 'temporary_id',
    'study_permit', 'work_permit', 'business_permit', 'visitor_visa', 'transit_visa',
    'permanent_residence', 'temporary_residence', 'refugee_permit', 'asylum_permit',
    'diplomatic_passport', 'exchange_permit', 'relatives_visa'
  ]),
  analysisType: z.enum(['field_extraction', 'validation', 'auto_fill_preparation']).default('field_extraction')
});

export const aiOcrProcessingRequestSchema = z.object({
  documentId: z.string().uuid(),
  documentType: z.enum([
    'birth_certificate', 'death_certificate', 'marriage_certificate', 'divorce_certificate',
    'passport', 'sa_id', 'smart_id', 'temporary_id',
    'study_permit', 'work_permit', 'business_permit', 'visitor_visa', 'transit_visa',
    'permanent_residence', 'temporary_residence', 'refugee_permit', 'asylum_permit',
    'diplomatic_passport', 'exchange_permit', 'relatives_visa'
  ]),
  targetFormType: z.string().optional(), // Form to auto-fill
  processingOptions: z.object({
    enableMrzParsing: z.boolean().default(false),
    enableFieldExtraction: z.boolean().default(true),
    enableValidation: z.boolean().default(true),
    enableAutoFill: z.boolean().default(false),
    qualityThreshold: z.number().min(0).max(100).default(70)
  }).default({})
});

export const aiAutoFillRequestSchema = z.object({
  sessionId: z.string().uuid(),
  formType: z.string(),
  existingFormData: z.record(z.any()).optional(),
  overrideFields: z.record(z.any()).optional() // Fields to override in auto-fill
});

// Web3 Blockchain Integration validation schemas
export const web3DocumentVerificationSchema = z.object({
  documentId: z.string().min(1).max(100),
  documentHash: z.string().min(64).max(64) // SHA-256 hash
});

export const web3BlockchainSignatureSchema = z.object({
  documentHash: z.string().min(64).max(64),
  signerAddress: z.string().min(40).max(42) // Ethereum address
});

export const web3NetworkQuerySchema = z.object({
  includeTestnets: z.boolean().optional().default(false)
});

// DHA VFS Integration validation schemas
export const dhaVfsIdentityVerificationSchema = z.object({
  idNumber: z.string().min(13).max(13), // South African ID number
  firstName: z.string().min(1).max(100),
  lastName: z.string().min(1).max(100),
  dateOfBirth: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  citizenship: z.string().min(2).max(3).optional()
});

export const dhaVfsBiometricVerificationSchema = z.object({
  idNumber: z.string().min(13).max(13),
  biometricData: z.object({
    fingerprints: z.array(z.string()).optional(),
    faceImage: z.string().optional(),
    signature: z.string().optional()
  }),
  verificationLevel: z.enum(['BASIC', 'ENHANCED', 'FULL']).default('BASIC')
});

export const dhaVfsDocumentVerificationSchema = z.object({
  documentNumber: z.string().min(1).max(50),
  documentType: z.enum(['passport', 'id_card', 'birth_certificate', 'marriage_certificate', 'death_certificate', 'asylum_seeker_permit', 'refugee_status', 'diplomatic_passport', 'official_passport', 'certificate_of_citizenship']),
  issueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  expiryDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional()
});

export const vfsApplicationStatusSchema = z.object({
  applicationNumber: z.string().min(1).max(50)
});

export const vfsApplicationSubmissionSchema = z.object({
  applicantDetails: z.object({
    firstName: z.string().min(1).max(100),
    lastName: z.string().min(1).max(100),
    idNumber: z.string().min(13).max(13),
    email: z.string().email(),
    phone: z.string().min(10).max(15)
  }),
  applicationType: z.enum(['passport', 'visa', 'permit', 'certificate']),
  urgency: z.enum(['standard', 'urgent', 'emergency']).default('standard'),
  supportingDocuments: z.array(z.string()).optional()
});

// AI Chat Assistant Response Types
export type AiChatRequest = z.infer<typeof aiChatRequestSchema>;
export type AiTranslationRequest = z.infer<typeof aiTranslationRequestSchema>;
export type AiDocumentAnalysisRequest = z.infer<typeof aiDocumentAnalysisRequestSchema>;
export type AiOcrProcessingRequest = z.infer<typeof aiOcrProcessingRequestSchema>;
export type AiAutoFillRequest = z.infer<typeof aiAutoFillRequestSchema>;

// Web3 and VFS Integration Response Types
export type Web3DocumentVerification = z.infer<typeof web3DocumentVerificationSchema>;
export type Web3BlockchainSignature = z.infer<typeof web3BlockchainSignatureSchema>;
export type Web3NetworkQuery = z.infer<typeof web3NetworkQuerySchema>;
export type DhaVfsIdentityVerification = z.infer<typeof dhaVfsIdentityVerificationSchema>;
export type DhaVfsBiometricVerification = z.infer<typeof dhaVfsBiometricVerificationSchema>;
export type DhaVfsDocumentVerification = z.infer<typeof dhaVfsDocumentVerificationSchema>;
export type VfsApplicationStatus = z.infer<typeof vfsApplicationStatusSchema>;
export type VfsApplicationSubmission = z.infer<typeof vfsApplicationSubmissionSchema>;

// Passport Number Validation
export const passportNumberSchema = z.string().regex(
  /^[A-Z]\d{8}$/,
  "South African passport number must be 1 letter followed by 8 digits"
);

// Document Verification Code Schema
export const documentVerificationCodeSchema = z.string().length(16).regex(
  /^[A-Z0-9]{16}$/,
  "Verification code must be 16 alphanumeric characters"
);

// Security Classification Validation
export const securityClassificationSchema = z.enum([
  "unclassified", "official", "confidential", "secret", "top_secret"
]).default("official");

// ===================== COMPREHENSIVE DHA SYSTEM STATUS =====================

/* 
 SOUTH AFRICAN DEPARTMENT OF HOME AFFAIRS DIGITAL SERVICES
 COMPREHENSIVE DATA MODEL - PRODUCTION READY

 DOCUMENT TYPES IMPLEMENTED (21 Total):
1.  Birth Certificate 
2.  South African ID  
3.  Passport (Ordinary, Diplomatic, Official) 
4.  Work Permit (All Sections) 
5.  Marriage Certificate 
6.  Death Certificate 
7.  Refugee ID 
8.  Temporary Residence Permit 
9.  Permanent Residence Permit 
10. Study Permit 
11. Business Permit 
12. Visitor's Visa 
13. Transit Visa 
14. Medical Treatment Visa 
15. Exchange Permit 
16. Relative's Visa (Spouse) 
17. Critical Skills Visa 
18. Intra-Company Transfer Visa 
19. Corporate Visa 
20. Treaty Visa 
21. Asylum/Refugee Documents 

 CORE SYSTEMS IMPLEMENTED:
- 8-Stage Processing Workflow 
- Comprehensive Biometric Integration 
- Advanced Fraud Detection 
- Government Security Classification 
- Real-time Document Verification 
- Complete Audit Trail System 
- POPIA/PFMA Compliance 
- WebSocket Notifications 
- Anti-Forgery Security Features 
- QR Code & Digital Signatures 

 TECHNICAL IMPLEMENTATION:
- Drizzle ORM with PostgreSQL 
- Comprehensive Insert Schemas 
- Type-Safe API Validation 
- Production Security Features 
- Government Compliance Ready 

 STATUS: PRODUCTION READY FOR DEPLOYMENT
*/


// ===================== AUTONOMOUS MONITORING BOT SCHEMA =====================

// Enums for Autonomous Monitoring
export const autonomousActionTypeEnum = pgEnum('autonomous_action_type', [
  'service_restart', 'cache_cleanup', 'database_maintenance', 'log_rotation',
  'disk_cleanup', 'memory_optimization', 'connection_reset', 'circuit_breaker_trip',
  'failover', 'data_repair', 'security_scan', 'performance_optimization',
  'alert_suppression', 'backup_creation', 'config_reload'
]);

export const autonomousActionStatusEnum = pgEnum('autonomous_action_status', [
  'initiated', 'in_progress', 'completed', 'failed', 'rolled_back', 'cancelled'
]);

export const maintenanceTaskTypeEnum = pgEnum('maintenance_task_type', [
  'database_vacuum', 'database_reindex', 'stats_update', 'log_cleanup',
  'disk_cleanup', 'cache_optimization', 'connection_pool_reset',
  'security_scan', 'backup_verification', 'performance_analysis'
]);

export const circuitBreakerStateEnum = pgEnum('circuit_breaker_state', [
  'closed', 'open', 'half_open'
]);

export const incidentSeverityEnum = pgEnum('incident_severity', [
  'low', 'medium', 'high', 'critical', 'emergency'
]);

export const incidentStatusEnum = pgEnum('incident_status', [
  'open', 'investigating', 'identified', 'monitoring', 'resolved', 'closed'
]);

export const complianceRequirementEnum = pgEnum('compliance_requirement', [
  'popia', 'pfma', 'government_uptime', 'security_incident_response',
  'data_protection', 'audit_trail', 'regulatory_reporting'
]);

// Autonomous Operations Log - Track all autonomous actions
export const autonomousOperations = pgTable("autonomous_operations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  actionType: autonomousActionTypeEnum("action_type").notNull(),
  targetService: text("target_service").notNull(), // e.g., 'database', 'cache', 'pdf_service'
  triggeredBy: text("triggered_by").notNull(), // 'health_check', 'error_threshold', 'scheduled'
  triggerDetails: jsonb("trigger_details"), // Details of what triggered the action
  
  // Action execution details
  status: autonomousActionStatusEnum("status").notNull().default("initiated"),
  startedAt: timestamp("started_at").notNull().default(sql`now()`),
  completedAt: timestamp("completed_at"),
  duration: integer("duration"), // milliseconds
  
  // Action results and impact
  actionParameters: jsonb("action_parameters"), // Parameters used for the action
  executionResults: jsonb("execution_results"), // Results and output of the action
  impactMetrics: jsonb("impact_metrics"), // Metrics before/after action
  rollbackDetails: jsonb("rollback_details"), // Details if rollback was needed
  
  // Government compliance and audit
  complianceFlags: jsonb("compliance_flags"), // Flags for regulatory compliance
  auditTrailId: varchar("audit_trail_id").references(() => auditLogs.id),
  approvalRequired: boolean("approval_required").notNull().default(false),
  approvedBy: varchar("approved_by").references(() => users.id),
  
  // Error handling
  errorMessage: text("error_message"),
  retryCount: integer("retry_count").notNull().default(0),
  maxRetries: integer("max_retries").notNull().default(3),
  nextRetryAt: timestamp("next_retry_at"),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// System Health Snapshots - Store detailed system health over time
export const systemHealthSnapshots = pgTable("system_health_snapshots", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  timestamp: timestamp("timestamp").notNull().default(sql`now()`),
  
  // System metrics
  cpuUsage: decimal("cpu_usage", { precision: 5, scale: 2 }), // Percentage
  memoryUsage: decimal("memory_usage", { precision: 5, scale: 2 }), // Percentage
  diskUsage: decimal("disk_usage", { precision: 5, scale: 2 }), // Percentage
  networkLatency: integer("network_latency"), // milliseconds
  
  // Application metrics
  activeConnections: integer("active_connections"),
  responseTime: integer("response_time"), // average milliseconds
  errorRate: decimal("error_rate", { precision: 5, scale: 2 }), // Percentage
  throughput: integer("throughput"), // requests per minute
  
  // Service-specific health
  databaseHealth: jsonb("database_health"), // Connection pool, query performance
  cacheHealth: jsonb("cache_health"), // Hit rates, memory usage
  apiHealth: jsonb("api_health"), // Endpoint response times, error rates
  externalServicesHealth: jsonb("external_services_health"), // Third-party service status
  
  // Security metrics
  securityScore: integer("security_score"), // Overall security posture 0-100
  threatLevel: severityEnum("threat_level").notNull().default("low"),
  activeSecurityIncidents: integer("active_security_incidents").notNull().default(0),
  fraudAlertsActive: integer("fraud_alerts_active").notNull().default(0),
  
  // Performance baselines and anomalies
  anomalyScore: decimal("anomaly_score", { precision: 3, scale: 2 }), // 0.00-1.00
  anomaliesDetected: jsonb("anomalies_detected"), // Array of detected anomalies
  performanceBaseline: jsonb("performance_baseline"), // Baseline metrics for comparison
  
  // Government compliance status
  complianceScore: integer("compliance_score"), // 0-100
  regulatoryViolations: jsonb("regulatory_violations"), // Active violations
  uptimePercentage: decimal("uptime_percentage", { precision: 5, scale: 2 }),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`)
});

// Circuit Breaker States - Track external service failures
export const circuitBreakerStates = pgTable("circuit_breaker_states", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  serviceName: text("service_name").notNull().unique(), // e.g., 'npr_service', 'saps_service'
  state: circuitBreakerStateEnum("state").notNull().default("closed"),
  
  // Failure tracking
  failureCount: integer("failure_count").notNull().default(0),
  failureThreshold: integer("failure_threshold").notNull().default(5),
  successCount: integer("success_count").notNull().default(0),
  successThreshold: integer("success_threshold").notNull().default(3),
  
  // Timing configuration
  timeout: integer("timeout").notNull().default(30000), // milliseconds
  lastFailureAt: timestamp("last_failure_at"),
  lastSuccessAt: timestamp("last_success_at"),
  nextRetryAt: timestamp("next_retry_at"),
  
  // Statistics
  totalRequests: integer("total_requests").notNull().default(0),
  totalFailures: integer("total_failures").notNull().default(0),
  averageResponseTime: integer("average_response_time"),
  
  // Recovery tracking
  stateChangedAt: timestamp("state_changed_at").notNull().default(sql`now()`),
  recoveryAttempts: integer("recovery_attempts").notNull().default(0),
  lastRecoveryAt: timestamp("last_recovery_at"),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Maintenance Tasks - Automated maintenance operations
export const maintenanceTasks = pgTable("maintenance_tasks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  taskType: maintenanceTaskTypeEnum("task_type").notNull(),
  taskName: text("task_name").notNull(),
  description: text("description"),
  
  // Scheduling
  schedulePattern: text("schedule_pattern").notNull(), // cron expression
  nextRunTime: timestamp("next_run_time").notNull(),
  lastRunTime: timestamp("last_run_time"),
  
  // Execution settings
  isEnabled: boolean("is_enabled").notNull().default(true),
  timeout: integer("timeout").notNull().default(300000), // 5 minutes
  maxRetries: integer("max_retries").notNull().default(3),
  retryDelay: integer("retry_delay").notNull().default(60000), // 1 minute
  
  // Task configuration
  taskParameters: jsonb("task_parameters"), // Task-specific parameters
  dependsOnTasks: jsonb("depends_on_tasks"), // Array of task IDs this depends on
  
  // Execution tracking
  status: autonomousActionStatusEnum("status").notNull().default("initiated"),
  executionCount: integer("execution_count").notNull().default(0),
  successCount: integer("success_count").notNull().default(0),
  failureCount: integer("failure_count").notNull().default(0),
  averageDuration: integer("average_duration"),
  
  // Results and impact
  lastExecutionResults: jsonb("last_execution_results"),
  performanceImpact: jsonb("performance_impact"), // Impact on system performance
  
  // Government compliance
  complianceRequired: boolean("compliance_required").notNull().default(false),
  auditTrailRequired: boolean("audit_trail_required").notNull().default(true),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Alert Rules - Intelligent alerting configuration
export const alertRules = pgTable("alert_rules", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  ruleName: text("rule_name").notNull().unique(),
  description: text("description"),
  category: text("category").notNull(), // 'performance', 'security', 'availability'
  
  // Rule conditions
  metricName: text("metric_name").notNull(),
  operator: text("operator").notNull(), // 'greater_than', 'less_than', 'equals', 'not_equals'
  threshold: decimal("threshold", { precision: 10, scale: 2 }).notNull(),
  duration: integer("duration").notNull().default(300), // seconds
  
  // Alert configuration
  severity: severityEnum("severity").notNull().default("medium"),
  isEnabled: boolean("is_enabled").notNull().default(true),
  suppressionWindow: integer("suppression_window").notNull().default(3600), // seconds
  
  // Smart alerting features
  smartClustering: boolean("smart_clustering").notNull().default(true),
  rootCauseAnalysis: boolean("root_cause_analysis").notNull().default(true),
  autoResolution: boolean("auto_resolution").notNull().default(false),
  escalationRules: jsonb("escalation_rules"), // Escalation configuration
  
  // Notification settings
  notificationChannels: jsonb("notification_channels"), // Array of channels
  recipientGroups: jsonb("recipient_groups"), // Array of user groups
  messageTemplate: text("message_template"),
  
  // Performance tracking
  triggerCount: integer("trigger_count").notNull().default(0),
  falsePositiveCount: integer("false_positive_count").notNull().default(0),
  averageResolutionTime: integer("average_resolution_time"),
  lastTriggeredAt: timestamp("last_triggered_at"),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Incidents - Automated incident management
export const incidents = pgTable("incidents", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  incidentNumber: text("incident_number").notNull().unique(), // Auto-generated INC-YYYY-NNNN
  title: text("title").notNull(),
  description: text("description"),
  
  // Classification
  severity: incidentSeverityEnum("severity").notNull(),
  status: incidentStatusEnum("status").notNull().default("open"),
  category: text("category").notNull(), // 'security', 'performance', 'availability'
  
  // Impact assessment
  impactLevel: severityEnum("impact_level").notNull().default("low"),
  affectedServices: jsonb("affected_services"), // Array of affected services
  affectedUsers: integer("affected_users"),
  businessImpact: text("business_impact"),
  
  // Resolution tracking
  assignedTo: varchar("assigned_to").references(() => users.id),
  assignedTeam: text("assigned_team"),
  priority: priorityLevelEnum("priority").notNull().default("normal"),
  
  // Timeline
  detectedAt: timestamp("detected_at").notNull().default(sql`now()`),
  acknowledgedAt: timestamp("acknowledged_at"),
  resolvedAt: timestamp("resolved_at"),
  closedAt: timestamp("closed_at"),
  
  // Autonomous actions
  triggerAlertRuleId: varchar("trigger_alert_rule_id").references(() => alertRules.id),
  autonomousActionsCount: integer("autonomous_actions_count").notNull().default(0),
  automaticResolution: boolean("automatic_resolution").notNull().default(false),
  
  // Root cause analysis
  rootCause: text("root_cause"),
  rootCauseAnalysis: jsonb("root_cause_analysis"), // AI-generated analysis
  preventiveMeasures: jsonb("preventive_measures"), // Actions to prevent recurrence
  
  // Government compliance
  governmentNotificationRequired: boolean("government_notification_required").notNull().default(false),
  governmentNotifiedAt: timestamp("government_notified_at"),
  complianceViolation: boolean("compliance_violation").notNull().default(false),
  regulatoryReporting: jsonb("regulatory_reporting"),
  
  // Communication
  communicationLog: jsonb("communication_log"), // Array of communications
  stakeholderUpdates: jsonb("stakeholder_updates"), // Updates sent to stakeholders
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Government Compliance Audit - Specialized audit for regulatory requirements
export const governmentComplianceAudit = pgTable("government_compliance_audit", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  auditId: text("audit_id").notNull().unique(), // GOV-AUDIT-YYYY-NNNN
  
  // Compliance tracking
  complianceRequirement: complianceRequirementEnum("compliance_requirement").notNull(),
  regulatoryFramework: text("regulatory_framework").notNull(), // 'POPIA', 'PFMA', etc.
  requirementDetails: jsonb("requirement_details"), // Specific requirement details
  
  // Audit details
  auditType: text("audit_type").notNull(), // 'automated', 'manual', 'scheduled'
  triggeredBy: text("triggered_by"), // What triggered this audit
  auditScope: jsonb("audit_scope"), // What was audited
  
  // Results
  complianceStatus: text("compliance_status").notNull(), // 'compliant', 'non_compliant', 'partial'
  findings: jsonb("findings"), // Audit findings
  violations: jsonb("violations"), // Any violations found
  riskLevel: riskLevelEnum("risk_level").notNull().default("low"),
  
  // Evidence and documentation
  evidenceCollected: jsonb("evidence_collected"), // Evidence supporting compliance
  documentationLinks: jsonb("documentation_links"), // Links to supporting documentation
  screenshotPaths: jsonb("screenshot_paths"), // Paths to screenshot evidence
  
  // Remediation
  remediationRequired: boolean("remediation_required").notNull().default(false),
  remediationPlan: jsonb("remediation_plan"), // Plan to address issues
  remediationDeadline: timestamp("remediation_deadline"),
  remediationCompleted: boolean("remediation_completed").notNull().default(false),
  
  // Reporting
  reportGenerated: boolean("report_generated").notNull().default(false),
  reportPath: text("report_path"), // Path to generated report
  reportSentAt: timestamp("report_sent_at"),
  reportRecipients: jsonb("report_recipients"), // Who received the report
  
  // Timeline
  auditStartedAt: timestamp("audit_started_at").notNull().default(sql`now()`),
  auditCompletedAt: timestamp("audit_completed_at"),
  nextAuditScheduled: timestamp("next_audit_scheduled"),
  
  // Accountability
  auditedBy: varchar("audited_by").references(() => users.id),
  reviewedBy: varchar("reviewed_by").references(() => users.id),
  approvedBy: varchar("approved_by").references(() => users.id),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Performance Baselines - Store baseline metrics for anomaly detection
export const performanceBaselines = pgTable("performance_baselines", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  metricName: text("metric_name").notNull(),
  serviceName: text("service_name").notNull(),
  
  // Baseline statistics
  baselineValue: decimal("baseline_value", { precision: 10, scale: 2 }).notNull(),
  standardDeviation: decimal("standard_deviation", { precision: 10, scale: 2 }),
  minValue: decimal("min_value", { precision: 10, scale: 2 }),
  maxValue: decimal("max_value", { precision: 10, scale: 2 }),
  
  // Time-based patterns
  hourlyPattern: jsonb("hourly_pattern"), // 24-hour pattern
  dailyPattern: jsonb("daily_pattern"), // 7-day pattern
  monthlyPattern: jsonb("monthly_pattern"), // 30-day pattern
  seasonalAdjustment: decimal("seasonal_adjustment", { precision: 5, scale: 2 }),
  
  // Anomaly detection settings
  anomalyThreshold: decimal("anomaly_threshold", { precision: 3, scale: 2 }).notNull().default("2.0"), // Standard deviations
  adaptiveLearning: boolean("adaptive_learning").notNull().default(true),
  
  // Update tracking
  lastCalculated: timestamp("last_calculated").notNull().default(sql`now()`),
  dataPointsUsed: integer("data_points_used").notNull(),
  validityPeriod: integer("validity_period").notNull().default(2592000), // 30 days in seconds
  
  // Performance tracking
  anomaliesDetected: integer("anomalies_detected").notNull().default(0),
  falsePositives: integer("false_positives").notNull().default(0),
  accuracy: decimal("accuracy", { precision: 5, scale: 2 }),
  
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`)
});

// Type exports for all new autonomous monitoring tables
export type AutonomousOperation = typeof autonomousOperations.$inferSelect;
export type InsertAutonomousOperation = typeof autonomousOperations.$inferInsert;

export type SystemHealthSnapshot = typeof systemHealthSnapshots.$inferSelect;
export type InsertSystemHealthSnapshot = typeof systemHealthSnapshots.$inferInsert;

export type CircuitBreakerState = typeof circuitBreakerStates.$inferSelect;
export type InsertCircuitBreakerState = typeof circuitBreakerStates.$inferInsert;

export type MaintenanceTask = typeof maintenanceTasks.$inferSelect;
export type InsertMaintenanceTask = typeof maintenanceTasks.$inferInsert;

export type AlertRule = typeof alertRules.$inferSelect;
export type InsertAlertRule = typeof alertRules.$inferInsert;

export type Incident = typeof incidents.$inferSelect;
export type InsertIncident = typeof incidents.$inferInsert;

export type GovernmentComplianceAudit = typeof governmentComplianceAudit.$inferSelect;
export type InsertGovernmentComplianceAudit = typeof governmentComplianceAudit.$inferInsert;

export type PerformanceBaseline = typeof performanceBaselines.$inferSelect;
export type InsertPerformanceBaseline = typeof performanceBaselines.$inferInsert;

// Zod schemas for autonomous monitoring
export const insertAutonomousOperationSchema = createInsertSchema(autonomousOperations);
export const insertSystemHealthSnapshotSchema = createInsertSchema(systemHealthSnapshots);
export const insertCircuitBreakerStateSchema = createInsertSchema(circuitBreakerStates);
export const insertMaintenanceTaskSchema = createInsertSchema(maintenanceTasks);
export const insertAlertRuleSchema = createInsertSchema(alertRules);
export const insertIncidentSchema = createInsertSchema(incidents);
export const insertGovernmentComplianceAuditSchema = createInsertSchema(governmentComplianceAudit);
export const insertPerformanceBaselineSchema = createInsertSchema(performanceBaselines);

// ===================== COMPLETE 21 DHA DOCUMENT VALIDATION SCHEMAS =====================

// Base personal details schema used across all document types
export const personalDetailsSchema = z.object({
  fullName: z.string().min(1, "Full name is required"),
  surname: z.string().min(1, "Surname is required"),
  givenNames: z.string().min(1, "Given names are required"),
  dateOfBirth: z.string().min(1, "Date of birth is required"),
  placeOfBirth: z.string().min(1, "Place of birth is required"),
  nationality: z.string().min(1, "Nationality is required"),
  passportNumber: z.string().optional(),
  idNumber: z.string().optional(),
  gender: z.enum(["M", "F", "X"]),
  maritalStatus: z.enum(["Single", "Married", "Divorced", "Widowed"]).optional(),
  countryOfBirth: z.string().min(1, "Country of birth is required"),
  photograph: z.string().optional() // Base64 encoded
});

// 1. SMART ID CARD
export const smartIdCardSchema = z.object({
  documentType: z.literal("smart_id_card"),
  personal: personalDetailsSchema,
  idNumber: z.string().min(13, "Valid SA ID number is required"),
  cardNumber: z.string().min(1, "Card number is required"),
  issuingDate: z.string().min(1, "Issuing date is required"),
  expiryDate: z.string().min(1, "Expiry date is required"),
  issuingOffice: z.string().min(1, "Issuing office is required"),
  emergencyContact: z.object({
    name: z.string(),
    relationship: z.string(),
    contactNumber: z.string()
  }).optional()
});

// 2. IDENTITY DOCUMENT BOOK (Green Book)
export const identityDocumentBookSchema = z.object({
  documentType: z.literal("identity_document_book"),
  personal: personalDetailsSchema,
  idNumber: z.string().min(13, "Valid SA ID number is required"),
  bookNumber: z.string().min(1, "Book number is required"),
  issuingDate: z.string().min(1, "Issuing date is required"),
  issuingOffice: z.string().min(1, "Issuing office is required"),
  previousIdNumber: z.string().optional(),
  parentDetails: z.object({
    motherFullName: z.string(),
    fatherFullName: z.string()
  }).optional()
});

// 3. TEMPORARY ID CERTIFICATE
export const temporaryIdCertificateSchema = z.object({
  documentType: z.literal("temporary_id_certificate"),
  personal: personalDetailsSchema,
  temporaryCertificateNumber: z.string().min(1, "Certificate number is required"),
  reasonForIssue: z.string().min(1, "Reason for issue is required"),
  issuingDate: z.string().min(1, "Issuing date is required"),
  expiryDate: z.string().min(1, "Expiry date is required"),
  issuingOffice: z.string().min(1, "Issuing office is required"),
  applicationReference: z.string().min(1, "Application reference is required")
});

// 4. SOUTH AFRICAN PASSPORT
export const southAfricanPassportSchema = z.object({
  documentType: z.literal("south_african_passport"),
  personal: personalDetailsSchema,
  passportNumber: z.string().min(1, "Passport number is required"),
  passportType: z.enum(["Ordinary", "Official", "Diplomatic"]).default("Ordinary"),
  dateOfIssue: z.string().min(1, "Date of issue is required"),
  dateOfExpiry: z.string().min(1, "Date of expiry is required"),
  placeOfIssue: z.string().min(1, "Place of issue is required"),
  issuingAuthority: z.string().default("Department of Home Affairs"),
  height: z.string().optional(),
  eyeColor: z.string().optional(),
  endorsements: z.array(z.string()).optional()
});

// 5. EMERGENCY TRAVEL CERTIFICATE
export const emergencyTravelCertificateSchema = z.object({
  documentType: z.literal("emergency_travel_certificate"),
  personal: personalDetailsSchema,
  certificateNumber: z.string().min(1, "Certificate number is required"),
  reasonForIssue: z.string().min(1, "Reason for emergency issue is required"),
  dateOfIssue: z.string().min(1, "Date of issue is required"),
  dateOfExpiry: z.string().min(1, "Date of expiry is required"),
  placeOfIssue: z.string().min(1, "Place of issue is required"),
  travelDestination: z.string().min(1, "Travel destination is required"),
  validForReturn: z.boolean().default(true)
});

// 6. REFUGEE TRAVEL DOCUMENT
export const refugeeTravelDocumentSchema = z.object({
  documentType: z.literal("refugee_travel_document"),
  personal: personalDetailsSchema,
  refugeeNumber: z.string().min(1, "Refugee number is required"),
  unhcrNumber: z.string().optional(),
  countryOfOrigin: z.string().min(1, "Country of origin is required"),
  dateOfEntry: z.string().min(1, "Date of entry into SA is required"),
  refugeeStatus: z.enum(["Refugee", "Asylum Seeker"]),
  dateOfIssue: z.string().min(1, "Date of issue is required"),
  dateOfExpiry: z.string().min(1, "Date of expiry is required"),
  travelRestrictions: z.array(z.string()).optional()
});

// 7. BIRTH CERTIFICATE
export const birthCertificateSchema = z.object({
  documentType: z.literal("birth_certificate"),
  childFullName: z.string().min(1, "Child's full name is required"),
  dateOfBirth: z.string().min(1, "Date of birth is required"),
  placeOfBirth: z.string().min(1, "Place of birth is required"),
  sex: z.enum(["Male", "Female"]),
  motherFullName: z.string().min(1, "Mother's full name is required"),
  motherAge: z.number().min(1).optional(),
  motherNationality: z.string().min(1, "Mother's nationality is required"),
  fatherFullName: z.string().min(1, "Father's full name is required"),
  fatherAge: z.number().min(1).optional(),
  fatherNationality: z.string().min(1, "Father's nationality is required"),
  registrationNumber: z.string().min(1, "Registration number is required"),
  registrationDate: z.string().min(1, "Registration date is required"),
  attendantType: z.string().optional(),
  attendantName: z.string().optional()
});

// 8. DEATH CERTIFICATE
export const deathCertificateSchema = z.object({
  documentType: z.literal("death_certificate"),
  deceasedFullName: z.string().min(1, "Deceased's full name is required"),
  dateOfBirth: z.string().min(1, "Date of birth is required"),
  dateOfDeath: z.string().min(1, "Date of death is required"),
  placeOfDeath: z.string().min(1, "Place of death is required"),
  causeOfDeath: z.string().min(1, "Cause of death is required"),
  mannerOfDeath: z.enum(["Natural", "Accident", "Suicide", "Homicide", "Undetermined"]).optional(),
  certifyingPhysician: z.string().min(1, "Certifying physician is required"),
  physicianRegistrationNumber: z.string().min(1, "Physician registration number is required"),
  informantName: z.string().min(1, "Informant name is required"),
  relationshipToDeceased: z.string().min(1, "Relationship to deceased is required"),
  registrationNumber: z.string().min(1, "Registration number is required"),
  registrationDate: z.string().min(1, "Registration date is required")
});

// 9. MARRIAGE CERTIFICATE
export const marriageCertificateSchema = z.object({
  documentType: z.literal("marriage_certificate"),
  partner1FullName: z.string().min(1, "Partner 1 full name is required"),
  partner1Age: z.number().min(18, "Must be at least 18 years old"),
  partner1Nationality: z.string().min(1, "Partner 1 nationality is required"),
  partner1Occupation: z.string().optional(),
  partner2FullName: z.string().min(1, "Partner 2 full name is required"),
  partner2Age: z.number().min(18, "Must be at least 18 years old"),
  partner2Nationality: z.string().min(1, "Partner 2 nationality is required"),
  partner2Occupation: z.string().optional(),
  marriageDate: z.string().min(1, "Marriage date is required"),
  marriagePlace: z.string().min(1, "Marriage place is required"),
  marriageType: z.enum(["Civil", "Religious", "Customary"]),
  officiantName: z.string().min(1, "Officiant name is required"),
  witness1Name: z.string().min(1, "Witness 1 name is required"),
  witness2Name: z.string().min(1, "Witness 2 name is required"),
  registrationNumber: z.string().min(1, "Registration number is required"),
  registrationDate: z.string().min(1, "Registration date is required")
});

// 10. DIVORCE CERTIFICATE
export const divorceCertificateSchema = z.object({
  documentType: z.literal("divorce_certificate"),
  husband: z.object({
    fullName: z.string().min(1, "Husband's full name is required"),
    idNumber: z.string().optional(),
    nationality: z.string().min(1, "Husband's nationality is required")
  }),
  wife: z.object({
    fullName: z.string().min(1, "Wife's full name is required"),
    idNumber: z.string().optional(),
    nationality: z.string().min(1, "Wife's nationality is required")
  }),
  marriageDate: z.string().min(1, "Marriage date is required"),
  marriageCertificateNumber: z.string().min(1, "Marriage certificate number is required"),
  divorceDate: z.string().min(1, "Divorce date is required"),
  divorceCourt: z.string().min(1, "Divorce court is required"),
  divorceDecreeNumber: z.string().min(1, "Divorce decree number is required"),
  groundsForDivorce: z.string().min(1, "Grounds for divorce are required")
});

// 11-21. IMMIGRATION DOCUMENTS (Visas and Permits)
const employerDetailsSchema = z.object({
  name: z.string().min(1, "Employer name is required"),
  address: z.string().min(1, "Employer address is required"),
  registrationNumber: z.string().min(1, "Registration number is required"),
  taxNumber: z.string().min(1, "Tax number is required"),
  contactPerson: z.string().min(1, "Contact person is required")
});

// 11. GENERAL WORK VISA
export const generalWorkVisaSchema = z.object({
  documentType: z.literal("general_work_visa"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  employer: employerDetailsSchema,
  occupation: z.string().min(1, "Occupation is required"),
  jobTitle: z.string().min(1, "Job title is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required"),
  conditions: z.array(z.string()).optional(),
  portOfEntry: z.string().min(1, "Port of entry is required")
});

// 12. CRITICAL SKILLS WORK VISA
export const criticalSkillsWorkVisaSchema = z.object({
  documentType: z.literal("critical_skills_work_visa"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  criticalSkillArea: z.string().min(1, "Critical skill area is required"),
  qualifications: z.array(z.object({
    degree: z.string(),
    institution: z.string(),
    year: z.string(),
    country: z.string()
  })).min(1, "At least one qualification is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required"),
  conditions: z.array(z.string()).optional()
});

// 13. INTRA-COMPANY TRANSFER WORK VISA
export const intraCompanyTransferWorkVisaSchema = z.object({
  documentType: z.literal("intra_company_transfer_work_visa"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  parentCompany: employerDetailsSchema,
  subsidiaryCompany: employerDetailsSchema,
  transferPosition: z.string().min(1, "Transfer position is required"),
  transferDuration: z.string().min(1, "Transfer duration is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 14. BUSINESS VISA
export const businessVisaSchema = z.object({
  documentType: z.literal("business_visa"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  businessType: z.string().min(1, "Business type is required"),
  investmentAmount: z.string().min(1, "Investment amount is required"),
  businessPlan: z.string().min(1, "Business plan is required"),
  jobsToBeCreated: z.number().min(1, "Number of jobs to be created is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 15. STUDY VISA/PERMIT
export const studyVisaPermitSchema = z.object({
  documentType: z.literal("study_visa_permit"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  institution: z.object({
    name: z.string().min(1, "Institution name is required"),
    address: z.string().min(1, "Institution address is required"),
    registrationNumber: z.string().min(1, "Institution registration number is required")
  }),
  course: z.string().min(1, "Course/qualification is required"),
  studyLevel: z.enum(["Certificate", "Diploma", "Degree", "Postgraduate"]),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 16. VISITOR VISA
export const visitorVisaSchema = z.object({
  documentType: z.literal("visitor_visa"),
  personal: personalDetailsSchema,
  visaNumber: z.string().min(1, "Visa number is required"),
  purposeOfVisit: z.string().min(1, "Purpose of visit is required"),
  durationOfStay: z.string().min(1, "Duration of stay is required"),
  accommodation: z.string().min(1, "Accommodation details are required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required"),
  numberOfEntries: z.enum(["Single", "Multiple"])
});

// 17. MEDICAL TREATMENT VISA
export const medicalTreatmentVisaSchema = z.object({
  documentType: z.literal("medical_treatment_visa"),
  personal: personalDetailsSchema,
  visaNumber: z.string().min(1, "Visa number is required"),
  medicalCondition: z.string().min(1, "Medical condition is required"),
  treatingHospital: z.string().min(1, "Treating hospital is required"),
  estimatedTreatmentDuration: z.string().min(1, "Estimated treatment duration is required"),
  accompanyingPersons: z.array(z.string()).optional(),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 18. RETIRED PERSON'S VISA
export const retiredPersonVisaSchema = z.object({
  documentType: z.literal("retired_person_visa"),
  personal: personalDetailsSchema,
  visaNumber: z.string().min(1, "Visa number is required"),
  retirementDate: z.string().min(1, "Retirement date is required"),
  monthlyIncome: z.string().min(1, "Monthly income proof is required"),
  pensionFundDetails: z.string().min(1, "Pension fund details are required"),
  medicalAidCover: z.string().min(1, "Medical aid cover is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 19. EXCHANGE VISA
export const exchangeVisaSchema = z.object({
  documentType: z.literal("exchange_visa"),
  personal: personalDetailsSchema,
  visaNumber: z.string().min(1, "Visa number is required"),
  exchangeProgram: z.string().min(1, "Exchange program is required"),
  hostInstitution: z.string().min(1, "Host institution is required"),
  sponsoringOrganization: z.string().min(1, "Sponsoring organization is required"),
  programDuration: z.string().min(1, "Program duration is required"),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 20. RELATIVES VISA
export const relativesVisaSchema = z.object({
  documentType: z.literal("relatives_visa"),
  personal: personalDetailsSchema,
  visaNumber: z.string().min(1, "Visa number is required"),
  relationship: z.string().min(1, "Relationship to SA citizen/resident is required"),
  sponsor: z.object({
    fullName: z.string().min(1, "Sponsor full name is required"),
    idNumber: z.string().min(1, "Sponsor ID number is required"),
    relationship: z.string().min(1, "Relationship to applicant is required"),
    address: z.string().min(1, "Sponsor address is required"),
    contactNumber: z.string().min(1, "Sponsor contact number is required")
  }),
  validFrom: z.string().min(1, "Valid from date is required"),
  validUntil: z.string().min(1, "Valid until date is required")
});

// 21. PERMANENT RESIDENCE PERMIT
export const permanentResidencePermitSchema = z.object({
  documentType: z.literal("permanent_residence_permit"),
  personal: personalDetailsSchema,
  permitNumber: z.string().min(1, "Permit number is required"),
  categoryOfAdmission: z.string().min(1, "Category of admission is required"),
  dateOfAdmission: z.string().min(1, "Date of admission is required"),
  conditions: z.array(z.string()).optional(),
  issuingDate: z.string().min(1, "Issuing date is required"),
  issuingOffice: z.string().min(1, "Issuing office is required"),
  previousPermitNumber: z.string().optional()
});

// 22. CERTIFICATE OF EXEMPTION (Section 6(2) of Act No.88 of 1995)
export const certificateOfExemptionSchema = z.object({
  documentType: z.literal("certificate_of_exemption"),
  referenceNumber: z.string().min(1, "Reference number is required"),
  fileNumber: z.string().min(1, "File number is required"),
  districtOffice: z.object({
    name: z.string().min(1, "District office name is required"),
    address: z.string().min(1, "District office address is required"),
    postalCode: z.string().min(1, "Postal code is required")
  }),
  exemptionDetails: z.object({
    actReference: z.string().default("Section 6(2) of Act No.88 of 1995"),
    exemptionText: z.string().min(1, "Exemption text is required"),
    conditions: z.array(z.string()).optional(),
    validityPeriod: z.string().optional()
  }),
  exemptedPerson: z.object({
    fullName: z.string().min(1, "Full name is required"),
    dateOfBirth: z.string().min(1, "Date of birth is required"),
    identityNumber: z.string().optional(),
    nationality: z.string().min(1, "Nationality is required"),
    address: z.string().optional()
  }),
  issuingDate: z.string().min(1, "Issuing date is required"),
  directorGeneral: z.object({
    name: z.string().min(1, "Director-General name is required"),
    signature: z.string().optional(),
    date: z.string().min(1, "Signature date is required")
  })
});

// 23. CERTIFICATE OF SOUTH AFRICAN CITIZENSHIP (Section 10, SA Citizenship Act 1995)
export const certificateOfSouthAfricanCitizenshipSchema = z.object({
  documentType: z.literal("certificate_of_south_african_citizenship"),
  certificateNumber: z.string().min(1, "Certificate number is required"),
  referenceNumber: z.string().min(1, "Reference number is required"),
  legalReference: z.string().default("Section 10, South African Citizenship Act 1995"),
  certificateText: z.object({
    purposeStatement: z.string().default("This certificate is issued for the sole purpose of indicating the status of the person concerned on the date of issue"),
    certificationText: z.string().min(1, "Certification text is required"),
    citizenshipType: z.enum(["birth", "descent", "naturalisation"]).default("birth")
  }),
  holder: z.object({
    fullName: z.string().min(1, "Full name is required"),
    placeOfBirth: z.string().min(1, "Place of birth is required"),
    dateOfBirth: z.string().min(1, "Date of birth is required"),
    identityNumber: z.string().min(1, "Identity number is required"),
    particulars: z.string().optional(),
    gender: z.enum(["Male", "Female"]).optional()
  }),
  ministerialAuthorization: z.object({
    byOrderOfMinister: z.string().default("By order of the Minister"),
    directorGeneralName: z.string().default("Director-General: Home Affairs"),
    signature: z.string().optional(),
    officialStamp: z.boolean().default(true)
  }),
  issuingDate: z.string().min(1, "Issuing date is required"),
  issuingOffice: z.string().min(1, "Issuing office is required")
});

// Document generation request schema that accepts any of the 23 document types
export const documentGenerationRequestSchema = z.discriminatedUnion("documentType", [
  smartIdCardSchema,
  identityDocumentBookSchema,
  temporaryIdCertificateSchema,
  southAfricanPassportSchema,
  emergencyTravelCertificateSchema,
  refugeeTravelDocumentSchema,
  birthCertificateSchema,
  deathCertificateSchema,
  marriageCertificateSchema,
  divorceCertificateSchema,
  generalWorkVisaSchema,
  criticalSkillsWorkVisaSchema,
  intraCompanyTransferWorkVisaSchema,
  businessVisaSchema,
  studyVisaPermitSchema,
  visitorVisaSchema,
  medicalTreatmentVisaSchema,
  retiredPersonVisaSchema,
  exchangeVisaSchema,
  relativesVisaSchema,
  permanentResidencePermitSchema,
  certificateOfExemptionSchema,
  certificateOfSouthAfricanCitizenshipSchema
]);

// Export all document type schemas for individual use
export const documentTypeSchemas = {
  smart_id_card: smartIdCardSchema,
  identity_document_book: identityDocumentBookSchema,
  temporary_id_certificate: temporaryIdCertificateSchema,
  south_african_passport: southAfricanPassportSchema,
  emergency_travel_certificate: emergencyTravelCertificateSchema,
  refugee_travel_document: refugeeTravelDocumentSchema,
  birth_certificate: birthCertificateSchema,
  death_certificate: deathCertificateSchema,
  marriage_certificate: marriageCertificateSchema,
  divorce_certificate: divorceCertificateSchema,
  general_work_visa: generalWorkVisaSchema,
  critical_skills_work_visa: criticalSkillsWorkVisaSchema,
  intra_company_transfer_work_visa: intraCompanyTransferWorkVisaSchema,
  business_visa: businessVisaSchema,
  study_visa_permit: studyVisaPermitSchema,
  visitor_visa: visitorVisaSchema,
  medical_treatment_visa: medicalTreatmentVisaSchema,
  retired_person_visa: retiredPersonVisaSchema,
  exchange_visa: exchangeVisaSchema,
  relatives_visa: relativesVisaSchema,
  permanent_residence_permit: permanentResidencePermitSchema,
  certificate_of_exemption: certificateOfExemptionSchema,
  certificate_of_south_african_citizenship: certificateOfSouthAfricanCitizenshipSchema
} as const;

// Type exports for all document schemas
export type DocumentGenerationRequest = z.infer<typeof documentGenerationRequestSchema>;
export type SmartIdCardData = z.infer<typeof smartIdCardSchema>;
export type IdentityDocumentBookData = z.infer<typeof identityDocumentBookSchema>;
export type TemporaryIdCertificateData = z.infer<typeof temporaryIdCertificateSchema>;
export type SouthAfricanPassportData = z.infer<typeof southAfricanPassportSchema>;
export type EmergencyTravelCertificateData = z.infer<typeof emergencyTravelCertificateSchema>;
export type RefugeeTravelDocumentData = z.infer<typeof refugeeTravelDocumentSchema>;
export type BirthCertificateData = z.infer<typeof birthCertificateSchema>;
export type DeathCertificateData = z.infer<typeof deathCertificateSchema>;
export type MarriageCertificateData = z.infer<typeof marriageCertificateSchema>;
export type DivorceCertificateData = z.infer<typeof divorceCertificateSchema>;
export type GeneralWorkVisaData = z.infer<typeof generalWorkVisaSchema>;
export type CriticalSkillsWorkVisaData = z.infer<typeof criticalSkillsWorkVisaSchema>;
export type IntraCompanyTransferWorkVisaData = z.infer<typeof intraCompanyTransferWorkVisaSchema>;
export type BusinessVisaData = z.infer<typeof businessVisaSchema>;
export type StudyVisaPermitData = z.infer<typeof studyVisaPermitSchema>;
export type VisitorVisaData = z.infer<typeof visitorVisaSchema>;
export type MedicalTreatmentVisaData = z.infer<typeof medicalTreatmentVisaSchema>;
export type RetiredPersonVisaData = z.infer<typeof retiredPersonVisaSchema>;
export type ExchangeVisaData = z.infer<typeof exchangeVisaSchema>;
export type RelativesVisaData = z.infer<typeof relativesVisaSchema>;
export type PermanentResidencePermitData = z.infer<typeof permanentResidencePermitSchema>;
export type CertificateOfExemptionData = z.infer<typeof certificateOfExemptionSchema>;
export type CertificateOfSouthAfricanCitizenshipData = z.infer<typeof certificateOfSouthAfricanCitizenshipSchema>;


